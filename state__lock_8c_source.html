<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>nfs-ganesha: state_lock.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">nfs-ganesha&#160;<span id="projectnumber">1.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>state_lock.c</h1>  </div>
</div>
<div class="contents">
<a href="state__lock_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * vim:expandtab:shiftwidth=8:tabstop=8:</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright CEA/DAM/DIF  (2008)</span>
<a name="l00005"></a>00005 <span class="comment"> * contributeur : Philippe DENIEL   philippe.deniel@cea.fr</span>
<a name="l00006"></a>00006 <span class="comment"> *                Thomas LEIBOVICI  thomas.leibovici@cea.fr</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
<a name="l00010"></a>00010 <span class="comment"> * modify it under the terms of the GNU Lesser General Public License</span>
<a name="l00011"></a>00011 <span class="comment"> * as published by the Free Software Foundation; either version 3 of</span>
<a name="l00012"></a>00012 <span class="comment"> * the License, or (at your option) any later version.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00015"></a>00015 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00016"></a>00016 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00017"></a>00017 <span class="comment"> * Lesser General Public License for more details.</span>
<a name="l00018"></a>00018 <span class="comment"> *</span>
<a name="l00019"></a>00019 <span class="comment"> * You should have received a copy of the GNU Lesser General Public</span>
<a name="l00020"></a>00020 <span class="comment"> * License along with this library; if not, write to the Free Software</span>
<a name="l00021"></a>00021 <span class="comment"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<a name="l00022"></a>00022 <span class="comment"> * 02110-1301 USA</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * ---------------------------------------</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 
<a name="l00035"></a>00035 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#include &quot;config.h&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#endif</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="preprocessor">#ifdef _SOLARIS</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#include &quot;solaris_port.h&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#endif                          </span><span class="comment">/* _SOLARIS */</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;time.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;log.h&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;HashData.h&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;HashTable.h&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;fsal.h&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;nfs_core.h&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;nfs4.h&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;sal_functions.h&quot;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#ifdef _USE_NLM</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#include &quot;nlm_util.h&quot;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#endif</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#include &quot;cache_inode_lru.h&quot;</span>
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="comment">/*</span>
<a name="l00063"></a>00063 <span class="comment"> * state_lock_entry_t locking rule:</span>
<a name="l00064"></a>00064 <span class="comment"> * The value is always updated/read with nlm_lock_entry-&gt;lock held</span>
<a name="l00065"></a>00065 <span class="comment"> * If we have nlm_lock_list mutex held we can read it safely, because the</span>
<a name="l00066"></a>00066 <span class="comment"> * value is always updated while walking the list with pentry-&gt;state_lock held.</span>
<a name="l00067"></a>00067 <span class="comment"> * The updation happens as below:</span>
<a name="l00068"></a>00068 <span class="comment"> *  pthread_rwlock_wrlock(&amp;pentry-&gt;state_mutex)</span>
<a name="l00069"></a>00069 <span class="comment"> *  pthread_mutex_lock(lock_entry-&gt;sle_mutex)</span>
<a name="l00070"></a>00070 <span class="comment"> *    update the lock_entry value</span>
<a name="l00071"></a>00071 <span class="comment"> *  ........</span>
<a name="l00072"></a>00072 <span class="comment"> * The value is ref counted with nlm_lock_entry-&gt;sle_ref_count so that a</span>
<a name="l00073"></a>00073 <span class="comment"> * parallel cancel/unlock won&#39;t endup freeing the datastructure. The last</span>
<a name="l00074"></a>00074 <span class="comment"> * release on the data structure ensure that it is freed.</span>
<a name="l00075"></a>00075 <span class="comment"> */</span>
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="comment">/* The following constant defines the number of errors we will accept</span>
<a name="l00078"></a>00078 <span class="comment"> * before giving up in state recovery routines. These routines need to</span>
<a name="l00079"></a>00079 <span class="comment"> * terminate at some point.</span>
<a name="l00080"></a>00080 <span class="comment"> */</span>
<a name="l00081"></a><a class="code" href="state__lock_8c.html#a28a5cdc8c44e19322b948741e0344107">00081</a> <span class="preprocessor">#define STATE_ERR_MAX 100</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span>
<a name="l00083"></a>00083 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a> state_all_locks;
<a name="l00085"></a>00085 pthread_mutex_t all_locks_mutex = PTHREAD_MUTEX_INITIALIZER;
<a name="l00086"></a>00086 <span class="preprocessor">#endif</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>
<a name="l00088"></a>00088 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span>
<a name="l00090"></a>00090 <span class="comment">/* List of all locks blocked in FSAL */</span>
<a name="l00091"></a>00091 <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a> state_blocked_locks;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="comment">/* List of all async blocking locks notified by FSAL but not processed */</span>
<a name="l00094"></a>00094 <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a> state_notified_locks;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="comment">/* Mutex to protect above lists */</span>
<a name="l00097"></a>00097 pthread_mutex_t blocked_locks_mutex = PTHREAD_MUTEX_INITIALIZER;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="preprocessor">#endif</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>
<a name="l00101"></a><a class="code" href="state__lock_8c.html#a54b5362efb0708c58ca5c23a0fe4bba5">00101</a> <a class="code" href="structstate__owner__t.html">state_owner_t</a> <a class="code" href="sal__data_8h.html#a54b5362efb0708c58ca5c23a0fe4bba5">unknown_owner</a>;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><a class="code" href="structhash__table.html">hash_table_t</a> *ht_lock_cookies;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> <a class="code" href="sal__functions_8h.html#aa664e4bb2b87ea1bdd2058188d4ae6ac">state_lock_init</a>(<a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>   * pstatus,
<a name="l00107"></a>00107                                <a class="code" href="structhash__param.html">hash_parameter_t</a>   cookie_param)
<a name="l00108"></a>00108 <span class="preprocessor">#else</span>
<a name="l00109"></a><a class="code" href="state__lock_8c.html#aa664e4bb2b87ea1bdd2058188d4ae6ac">00109</a> <span class="preprocessor"></span><a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> <a class="code" href="sal__functions_8h.html#aa664e4bb2b87ea1bdd2058188d4ae6ac">state_lock_init</a>(<a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> * pstatus)
<a name="l00110"></a>00110 <span class="preprocessor">#endif</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span>{
<a name="l00112"></a>00112   *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l00113"></a>00113 
<a name="l00114"></a>00114   memset(&amp;unknown_owner, 0, <span class="keyword">sizeof</span>(unknown_owner));
<a name="l00115"></a>00115   strcpy(unknown_owner.<a class="code" href="structstate__owner__t.html#a233106d13bab3610f0f2d0df15279d1a">so_owner_val</a>, <span class="stringliteral">&quot;ganesha_unknown_owner&quot;</span>);
<a name="l00116"></a>00116   unknown_owner.<a class="code" href="structstate__owner__t.html#a348f822632529b5aa366e84b1b5edeea">so_type</a>      = <a class="code" href="sal__data_8h.html#aa24f9f02b90bb72f27c7349957b4d2b0a5a410d3f3b6d3cb7d08962d8d1a4e6f7">STATE_LOCK_OWNER_UNKNOWN</a>;
<a name="l00117"></a>00117   unknown_owner.<a class="code" href="structstate__owner__t.html#a1aaaea6f21ab12d5f146d7f9b3e32b7f">so_refcount</a>  = 1;
<a name="l00118"></a>00118   unknown_owner.<a class="code" href="structstate__owner__t.html#a6de6ac9ea5654d3604040a4e14344e1b">so_owner_len</a> = strlen(unknown_owner.<a class="code" href="structstate__owner__t.html#a233106d13bab3610f0f2d0df15279d1a">so_owner_val</a>);
<a name="l00119"></a>00119 
<a name="l00120"></a>00120   init_glist(&amp;unknown_owner.<a class="code" href="structstate__owner__t.html#a769981c093a67e98f4b8aa95bdd122ed">so_lock_list</a>);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122   <span class="keywordflow">if</span>(pthread_mutex_init(&amp;unknown_owner.<a class="code" href="structstate__owner__t.html#a48a1d1f3663a55fa4ee7180dfcc02238">so_mutex</a>, <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) == -1)
<a name="l00123"></a>00123     {
<a name="l00124"></a>00124       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba2783ae87ebe127c19148ba00c794404f">STATE_INIT_ENTRY_FAILED</a>;
<a name="l00125"></a>00125       <span class="keywordflow">return</span> *pstatus;
<a name="l00126"></a>00126     }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>  ht_lock_cookies = <a class="code" href="group__HTExported.html#ga49502e8329739f9789ec4423289235d2" title="Initialize a new hash table.">HashTable_Init</a>(&amp;cookie_param);
<a name="l00130"></a>00130   <span class="keywordflow">if</span>(ht_lock_cookies == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00131"></a>00131     {
<a name="l00132"></a>00132       <a class="code" href="test__findlog_8c.html#adfd9432c5478fa14c7d678edb301feed">LogCrit</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l00133"></a>00133               <span class="stringliteral">&quot;Cannot init NLM Client cache&quot;</span>);
<a name="l00134"></a>00134       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba2783ae87ebe127c19148ba00c794404f">STATE_INIT_ENTRY_FAILED</a>;
<a name="l00135"></a>00135       <span class="keywordflow">return</span> *pstatus;
<a name="l00136"></a>00136     }
<a name="l00137"></a>00137 <span class="preprocessor">#endif</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span>
<a name="l00139"></a>00139 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>  init_glist(&amp;state_all_locks);
<a name="l00141"></a>00141 <span class="preprocessor">#endif</span>
<a name="l00142"></a>00142 <span class="preprocessor"></span> 
<a name="l00143"></a>00143 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span>  init_glist(&amp;state_blocked_locks);
<a name="l00145"></a>00145   init_glist(&amp;state_notified_locks);
<a name="l00146"></a>00146 
<a name="l00147"></a>00147   *pstatus = <a class="code" href="state__async_8c.html#aef2396b630f77ede2a0beaa08dc6797a">state_async_init</a>();
<a name="l00148"></a>00148 <span class="preprocessor">#endif</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span>
<a name="l00150"></a>00150   <a class="code" href="sal__data_8h.html#a7285dc832575c97c77ceaf5352c25d94">state_owner_pool</a> = pool_init(<span class="stringliteral">&quot;NFSv4 state owners&quot;</span>,
<a name="l00151"></a>00151                                <span class="keyword">sizeof</span>(<a class="code" href="structstate__owner__t.html">state_owner_t</a>),
<a name="l00152"></a>00152                                pool_basic_substrate,
<a name="l00153"></a>00153                                <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00154"></a>00154   <a class="code" href="sal__data_8h.html#ad575a734f47a0b59d80f269943407c98">state_nfs4_owner_name_pool</a> = pool_init(<span class="stringliteral">&quot;Owner names&quot;</span>,
<a name="l00155"></a>00155                                          <span class="keyword">sizeof</span>(<a class="code" href="structstate__nfs4__owner__name__t.html">state_nfs4_owner_name_t</a>),
<a name="l00156"></a>00156                                          pool_basic_substrate,
<a name="l00157"></a>00157                                          <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00158"></a>00158   <a class="code" href="sal__data_8h.html#ab0ba7f136f90d42db96822222a45c5c9">state_v4_pool</a> = pool_init(<span class="stringliteral">&quot;NFSv4 files states&quot;</span>,
<a name="l00159"></a>00159                             <span class="keyword">sizeof</span>(<a class="code" href="structstate__t.html">state_t</a>),
<a name="l00160"></a>00160                             pool_basic_substrate,
<a name="l00161"></a>00161                             <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00162"></a>00162   <span class="keywordflow">return</span> *pstatus;
<a name="l00163"></a>00163 }
<a name="l00164"></a>00164 
<a name="l00165"></a><a class="code" href="state__lock_8c.html#ae3f90b2b0f41f7eff5fef21dde258371">00165</a> bool_t <a class="code" href="state__lock_8c.html#ae3f90b2b0f41f7eff5fef21dde258371">lock_owner_is_nlm</a>(<a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> * lock_entry)
<a name="l00166"></a>00166 {
<a name="l00167"></a>00167 <span class="preprocessor">#ifdef _USE_NLM</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>  <span class="keywordflow">return</span> lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>-&gt;<a class="code" href="structstate__owner__t.html#a348f822632529b5aa366e84b1b5edeea">so_type</a> == STATE_LOCK_OWNER_NLM;
<a name="l00169"></a>00169 <span class="preprocessor">#else</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00171"></a>00171 <span class="preprocessor">#endif</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span>}
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> <a class="code" href="state__lock_8c.html#a1b7532d0b0321fdd328c9057087b1cfb">do_lock_op</a>(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l00175"></a>00175                           <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l00176"></a>00176                           <a class="code" href="structexportlist____.html">exportlist_t</a>         * pexport,
<a name="l00177"></a>00177                           <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20">fsal_lock_op_t</a>         lock_op,
<a name="l00178"></a>00178                           <a class="code" href="structstate__owner__t.html">state_owner_t</a>        * powner,
<a name="l00179"></a>00179                           <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * plock,
<a name="l00180"></a>00180                           <a class="code" href="structstate__owner__t.html">state_owner_t</a>       ** holder,   <span class="comment">/* owner that holds conflicting lock */</span>
<a name="l00181"></a>00181                           <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * conflict, <span class="comment">/* description of conflicting lock */</span>
<a name="l00182"></a>00182                           bool_t                 overlap);  <span class="comment">/* hint that lock overlaps */</span>
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="comment">/******************************************************************************</span>
<a name="l00185"></a>00185 <span class="comment"> *</span>
<a name="l00186"></a>00186 <span class="comment"> * Functions to display various aspects of a lock</span>
<a name="l00187"></a>00187 <span class="comment"> *</span>
<a name="l00188"></a>00188 <span class="comment"> ******************************************************************************/</span>
<a name="l00189"></a>00189 <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a> <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(<a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a> *plock)
<a name="l00190"></a>00190 {
<a name="l00191"></a>00191   <span class="keywordflow">if</span>(plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a> == 0)
<a name="l00192"></a>00192     <span class="keywordflow">return</span> UINT64_MAX;
<a name="l00193"></a>00193   <span class="keywordflow">else</span>
<a name="l00194"></a>00194     <span class="keywordflow">return</span> plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> + plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a> - 1;
<a name="l00195"></a>00195 }
<a name="l00196"></a>00196 
<a name="l00197"></a><a class="code" href="state__lock_8c.html#ab14c3d284d8c8926d94d1affda7becfe">00197</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="state__lock_8c.html#ab14c3d284d8c8926d94d1affda7becfe">str_lockt</a>(<a class="code" href="fsal__types_8h.html#aab76e308a0e07a7fcb4f4182ca3c098c">fsal_lock_t</a> ltype)
<a name="l00198"></a>00198 {
<a name="l00199"></a>00199   <span class="keywordflow">switch</span>(ltype)
<a name="l00200"></a>00200     {
<a name="l00201"></a>00201       <span class="keywordflow">case</span> <a class="code" href="fsal__types_8h.html#aab76e308a0e07a7fcb4f4182ca3c098caa8633965558922590799e083782fb423">FSAL_LOCK_R</a>:  <span class="keywordflow">return</span> <span class="stringliteral">&quot;READ &quot;</span>;
<a name="l00202"></a>00202       <span class="keywordflow">case</span> <a class="code" href="fsal__types_8h.html#aab76e308a0e07a7fcb4f4182ca3c098ca26e942e5ccc850086303fb166d2e1624">FSAL_LOCK_W</a>:  <span class="keywordflow">return</span> <span class="stringliteral">&quot;WRITE&quot;</span>;
<a name="l00203"></a>00203       <span class="keywordflow">case</span> <a class="code" href="fsal__types_8h.html#aab76e308a0e07a7fcb4f4182ca3c098ca4e89b7aafc925599e8a7083af9db9c65">FSAL_NO_LOCK</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;NO LOCK&quot;</span>;
<a name="l00204"></a>00204       <span class="keywordflow">default</span>:           <span class="keywordflow">return</span> <span class="stringliteral">&quot;?????&quot;</span>;
<a name="l00205"></a>00205     }
<a name="l00206"></a>00206   <span class="keywordflow">return</span> <span class="stringliteral">&quot;????&quot;</span>;
<a name="l00207"></a>00207 }
<a name="l00208"></a>00208 
<a name="l00209"></a><a class="code" href="state__lock_8c.html#a6fe45ec9846596e4d1ea9bce9d45d9c5">00209</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="state__lock_8c.html#a6fe45ec9846596e4d1ea9bce9d45d9c5">str_blocking</a>(<a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8f">state_blocking_t</a> blocking)
<a name="l00210"></a>00210 {
<a name="l00211"></a>00211   <span class="keywordflow">switch</span>(blocking)
<a name="l00212"></a>00212     {
<a name="l00213"></a>00213       <span class="keywordflow">case</span> <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8facf0a49c1e4b5d2ab379c0b9c61df625d">STATE_NON_BLOCKING</a>:   <span class="keywordflow">return</span> <span class="stringliteral">&quot;NON_BLOCKING  &quot;</span>;
<a name="l00214"></a>00214       <span class="keywordflow">case</span> <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa1f8b0da78f5ae271f0ff4c1ed4faf586">STATE_NLM_BLOCKING</a>:   <span class="keywordflow">return</span> <span class="stringliteral">&quot;NLM_BLOCKING  &quot;</span>;
<a name="l00215"></a>00215       <span class="keywordflow">case</span> <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fafdc4ecdcd48b788e6b4ceb21e112dbb4">STATE_NFSV4_BLOCKING</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;NFSV4_BLOCKING&quot;</span>;
<a name="l00216"></a>00216       <span class="keywordflow">case</span> <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa90ad1f35643849c6891a9fda17568fd9">STATE_GRANTING</a>:       <span class="keywordflow">return</span> <span class="stringliteral">&quot;GRANTING      &quot;</span>;
<a name="l00217"></a>00217       <span class="keywordflow">case</span> <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fac759db4905b8050e53794a5664963f52">STATE_CANCELED</a>:       <span class="keywordflow">return</span> <span class="stringliteral">&quot;CANCELED      &quot;</span>;
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219   <span class="keywordflow">return</span> <span class="stringliteral">&quot;unknown       &quot;</span>;
<a name="l00220"></a>00220 }
<a name="l00221"></a>00221 
<a name="l00222"></a><a class="code" href="state__lock_8c.html#a1d2e069f4bfd755214775ef4b7a7eb6f">00222</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="state__lock_8c.html#a1d2e069f4bfd755214775ef4b7a7eb6f">str_blocked</a>(<a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8f">state_blocking_t</a> blocked)
<a name="l00223"></a>00223 {
<a name="l00224"></a>00224   <span class="keywordflow">switch</span>(blocked)
<a name="l00225"></a>00225     {
<a name="l00226"></a>00226       <span class="keywordflow">case</span> <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8facf0a49c1e4b5d2ab379c0b9c61df625d">STATE_NON_BLOCKING</a>:   <span class="keywordflow">return</span> <span class="stringliteral">&quot;GRANTED       &quot;</span>;
<a name="l00227"></a>00227       <span class="keywordflow">case</span> <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa1f8b0da78f5ae271f0ff4c1ed4faf586">STATE_NLM_BLOCKING</a>:   <span class="keywordflow">return</span> <span class="stringliteral">&quot;NLM_BLOCKING  &quot;</span>;
<a name="l00228"></a>00228       <span class="keywordflow">case</span> <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fafdc4ecdcd48b788e6b4ceb21e112dbb4">STATE_NFSV4_BLOCKING</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;NFSV4_BLOCKING&quot;</span>;
<a name="l00229"></a>00229       <span class="keywordflow">case</span> <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa90ad1f35643849c6891a9fda17568fd9">STATE_GRANTING</a>:       <span class="keywordflow">return</span> <span class="stringliteral">&quot;GRANTING      &quot;</span>;
<a name="l00230"></a>00230       <span class="keywordflow">case</span> <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fac759db4905b8050e53794a5664963f52">STATE_CANCELED</a>:       <span class="keywordflow">return</span> <span class="stringliteral">&quot;CANCELED      &quot;</span>;
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232   <span class="keywordflow">return</span> <span class="stringliteral">&quot;unknown       &quot;</span>;
<a name="l00233"></a>00233 }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 <span class="comment">/******************************************************************************</span>
<a name="l00236"></a>00236 <span class="comment"> *</span>
<a name="l00237"></a>00237 <span class="comment"> * Function to compare lock parameters</span>
<a name="l00238"></a>00238 <span class="comment"> *</span>
<a name="l00239"></a>00239 <span class="comment"> ******************************************************************************/</span>
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="comment">/* This is not complete, it doesn&#39;t check the owner&#39;s IP address...*/</span>
<a name="l00242"></a>00242 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> different_lock(<a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a> *lock1, <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a> *lock2)
<a name="l00243"></a>00243 {
<a name="l00244"></a>00244   <span class="keywordflow">return</span> (lock1-&gt;<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a>   != lock2-&gt;<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a>)  ||
<a name="l00245"></a>00245          (lock1-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>  != lock2-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>) ||
<a name="l00246"></a>00246          (lock1-&gt;<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a> != lock2-&gt;<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a>);
<a name="l00247"></a>00247 }
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 <span class="comment">/******************************************************************************</span>
<a name="l00250"></a>00250 <span class="comment"> *</span>
<a name="l00251"></a>00251 <span class="comment"> * Functions to log locks in various ways</span>
<a name="l00252"></a>00252 <span class="comment"> *</span>
<a name="l00253"></a>00253 <span class="comment"> ******************************************************************************/</span>
<a name="l00254"></a>00254 <span class="keyword">static</span> <span class="keywordtype">void</span> LogEntry(<span class="keyword">const</span> <span class="keywordtype">char</span>         *reason,
<a name="l00255"></a>00255                      <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *ple)
<a name="l00256"></a>00256 {
<a name="l00257"></a>00257   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>))
<a name="l00258"></a>00258     {
<a name="l00259"></a>00259       <span class="keywordtype">char</span> owner[HASHTABLE_DISPLAY_STRLEN];
<a name="l00260"></a>00260 
<a name="l00261"></a>00261       <a class="code" href="sal__functions_8h.html#a1abfb205d2e54a2f02769650dfd22da8">DisplayOwner</a>(ple-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>, owner);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l00264"></a>00264                    <span class="stringliteral">&quot;%s Entry: %p pentry=%p, fileid=%&quot;</span>PRIu64<span class="stringliteral">&quot;, export=%u, type=%s, start=0x%llx, end=0x%llx, blocked=%s/%p, state=%p, refcount=%d, owner={%s}&quot;</span>,
<a name="l00265"></a>00265                    reason, ple,
<a name="l00266"></a>00266                    ple-&gt;<a class="code" href="structstate__lock__entry__t.html#aab01a34cef6e6bbeea32a83e906b7f32">sle_pentry</a>, (<a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a>)ple-&gt;<a class="code" href="structstate__lock__entry__t.html#aab01a34cef6e6bbeea32a83e906b7f32">sle_pentry</a>-&gt;<a class="code" href="structcache__entry__t.html#aad2a56294dcb57329b3b9fcd56e31f27">attributes</a>.<a class="code" href="structfsal__attrib__list____.html#a657a3efbc26891ced4b16f48791452c3">fileid</a>,
<a name="l00267"></a>00267                    (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) ple-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>-&gt;<a class="code" href="structexportlist____.html#a6cdf6b3326db83e0af2976000c374b12">id</a>,
<a name="l00268"></a>00268                    <a class="code" href="state__lock_8c.html#ab14c3d284d8c8926d94d1affda7becfe">str_lockt</a>(ple-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a>),
<a name="l00269"></a>00269                    (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) ple-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>,
<a name="l00270"></a>00270                    (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(&amp;ple-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>),
<a name="l00271"></a>00271                    <a class="code" href="state__lock_8c.html#a1d2e069f4bfd755214775ef4b7a7eb6f">str_blocked</a>(ple-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a>),
<a name="l00272"></a>00272                    ple-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>,
<a name="l00273"></a>00273                    ple-&gt;<a class="code" href="structstate__lock__entry__t.html#abb0ab635935d64b79bb2a6d3ee328731">sle_state</a>,
<a name="l00274"></a>00274                    ple-&gt;<a class="code" href="structstate__lock__entry__t.html#a4bcbf0d0f30014bab3b90583f90d5e5f">sle_ref_count</a>,
<a name="l00275"></a>00275                    owner);
<a name="l00276"></a>00276     }
<a name="l00277"></a>00277 }
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="keyword">static</span> bool_t LogList(<span class="keyword">const</span> <span class="keywordtype">char</span>        * reason,
<a name="l00280"></a>00280                       <a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>     * pentry,
<a name="l00281"></a>00281                       <span class="keyword">struct</span> <a class="code" href="structglist__head.html">glist_head</a> * list)
<a name="l00282"></a>00282 {
<a name="l00283"></a>00283   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>))
<a name="l00284"></a>00284     {
<a name="l00285"></a>00285       <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a>  * glist;
<a name="l00286"></a>00286       <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> * found_entry;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288       <span class="keywordflow">if</span>(glist_empty(list))
<a name="l00289"></a>00289         {
<a name="l00290"></a>00290           <span class="keywordflow">if</span>(pentry != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00291"></a>00291             <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l00292"></a>00292                          <span class="stringliteral">&quot;%s for %p is empty&quot;</span>,
<a name="l00293"></a>00293                          reason, pentry);
<a name="l00294"></a>00294           <span class="keywordflow">else</span>
<a name="l00295"></a>00295             <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l00296"></a>00296                          <span class="stringliteral">&quot;%s is empty&quot;</span>,
<a name="l00297"></a>00297                          reason);
<a name="l00298"></a>00298           <span class="keywordflow">return</span> <a class="code" href="HashTable_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00299"></a>00299         }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 
<a name="l00302"></a>00302       <a class="code" href="nlm__list_8h.html#a39dd5015f511354bf29ba3cec9a3987b">glist_for_each</a>(glist, list)
<a name="l00303"></a>00303         {
<a name="l00304"></a>00304           found_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l00305"></a>00305           LogEntry(reason, found_entry);
<a name="l00306"></a>00306           <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#aab01a34cef6e6bbeea32a83e906b7f32">sle_pentry</a> == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00307"></a>00307             <span class="keywordflow">break</span>;
<a name="l00308"></a>00308         }
<a name="l00309"></a>00309     }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311   <span class="keywordflow">return</span> <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00312"></a>00312 }
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l00315"></a>00315 <span class="preprocessor"></span><span class="keyword">static</span> bool_t LogBlockedList(<span class="keyword">const</span> <span class="keywordtype">char</span>        * reason,
<a name="l00316"></a>00316                              <a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>     * pentry,
<a name="l00317"></a>00317                              <span class="keyword">struct</span> <a class="code" href="structglist__head.html">glist_head</a> * list)
<a name="l00318"></a>00318 {
<a name="l00319"></a>00319   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>))
<a name="l00320"></a>00320     {
<a name="l00321"></a>00321       <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a>  * glist;
<a name="l00322"></a>00322       <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> * found_entry;
<a name="l00323"></a>00323       <a class="code" href="sal__data_8h.html#a3035370b7b027cc7c897284b50c5fc12">state_block_data_t</a> * block_entry;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325       <span class="keywordflow">if</span>(glist_empty(list))
<a name="l00326"></a>00326         {
<a name="l00327"></a>00327           <span class="keywordflow">if</span>(pentry != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00328"></a>00328             <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l00329"></a>00329                          <span class="stringliteral">&quot;%s for %p is empty&quot;</span>,
<a name="l00330"></a>00330                          reason, pentry);
<a name="l00331"></a>00331           <span class="keywordflow">else</span>
<a name="l00332"></a>00332             <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l00333"></a>00333                          <span class="stringliteral">&quot;%s is empty&quot;</span>,
<a name="l00334"></a>00334                          reason);
<a name="l00335"></a>00335           <span class="keywordflow">return</span> <a class="code" href="HashTable_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00336"></a>00336         }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 
<a name="l00339"></a>00339       <a class="code" href="nlm__list_8h.html#a39dd5015f511354bf29ba3cec9a3987b">glist_for_each</a>(glist, list)
<a name="l00340"></a>00340         {
<a name="l00341"></a>00341           block_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="sal__data_8h.html#a3035370b7b027cc7c897284b50c5fc12">state_block_data_t</a>, sbd_list);
<a name="l00342"></a>00342           found_entry = block_entry-&gt;sbd_lock_entry;
<a name="l00343"></a>00343           LogEntry(reason, found_entry);
<a name="l00344"></a>00344           <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#aab01a34cef6e6bbeea32a83e906b7f32">sle_pentry</a> == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00345"></a>00345             <span class="keywordflow">break</span>;
<a name="l00346"></a>00346         }
<a name="l00347"></a>00347     }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349   <span class="keywordflow">return</span> <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00350"></a>00350 }
<a name="l00351"></a>00351 <span class="preprocessor">#endif </span><span class="comment">/* _USE_BLOCKING_LOCKS */</span>
<a name="l00352"></a>00352 
<a name="l00353"></a><a class="code" href="state__lock_8c.html#ad62a073d73c565a7d2bbc850bc16e617">00353</a> <span class="keywordtype">void</span> <a class="code" href="sal__functions_8h.html#ad62a073d73c565a7d2bbc850bc16e617">LogLock</a>(<a class="code" href="log_8h.html#a80c77121778df3130d72817d3d1a9451">log_components_t</a>     component,
<a name="l00354"></a>00354              <a class="code" href="log_8h.html#a7d610232186d5b534b8bcb9081442744">log_levels_t</a>         debug,
<a name="l00355"></a>00355              <span class="keyword">const</span> <span class="keywordtype">char</span>         * reason,
<a name="l00356"></a>00356              <a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>      * pentry,
<a name="l00357"></a>00357              <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>  * pcontext,
<a name="l00358"></a>00358              <a class="code" href="structstate__owner__t.html">state_owner_t</a>      * powner,
<a name="l00359"></a>00359              <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>  * plock)
<a name="l00360"></a>00360 {
<a name="l00361"></a>00361   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#a4fc63fb32d3f6589fae63cecc4e3f44f">isLevel</a>(component, debug))
<a name="l00362"></a>00362     {
<a name="l00363"></a>00363       <span class="keywordtype">char</span> owner[HASHTABLE_DISPLAY_STRLEN];
<a name="l00364"></a>00364 
<a name="l00365"></a>00365       <span class="keywordflow">if</span>(powner != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00366"></a>00366         <a class="code" href="sal__functions_8h.html#a1abfb205d2e54a2f02769650dfd22da8">DisplayOwner</a>(powner, owner);
<a name="l00367"></a>00367       <span class="keywordflow">else</span>
<a name="l00368"></a>00368         sprintf(owner, <span class="stringliteral">&quot;NONE&quot;</span>);
<a name="l00369"></a>00369 
<a name="l00370"></a>00370       <a class="code" href="log_8h.html#aa2e3d19c50b7644277f99c1d661c39bf">LogAtLevel</a>(component, debug,
<a name="l00371"></a>00371                  <span class="stringliteral">&quot;%s Lock: pentry=%p, fileid=%&quot;</span>PRIu64<span class="stringliteral">&quot;, type=%s, start=0x%llx, end=0x%llx, owner={%s}&quot;</span>,
<a name="l00372"></a>00372                  reason, pentry, (<a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a>)pentry-&gt;<a class="code" href="structcache__entry__t.html#aad2a56294dcb57329b3b9fcd56e31f27">attributes</a>.<a class="code" href="structfsal__attrib__list____.html#a657a3efbc26891ced4b16f48791452c3">fileid</a>,
<a name="l00373"></a>00373                  <a class="code" href="state__lock_8c.html#ab14c3d284d8c8926d94d1affda7becfe">str_lockt</a>(plock-&gt;<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a>),
<a name="l00374"></a>00374                  (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>,
<a name="l00375"></a>00375                  (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(plock),
<a name="l00376"></a>00376                  owner);
<a name="l00377"></a>00377     }
<a name="l00378"></a>00378 }
<a name="l00379"></a>00379 
<a name="l00380"></a><a class="code" href="state__lock_8c.html#ab374e881221a11ba142358747dd37603">00380</a> <span class="keywordtype">void</span> <a class="code" href="state__lock_8c.html#ab374e881221a11ba142358747dd37603">LogLockDesc</a>(<a class="code" href="log_8h.html#a80c77121778df3130d72817d3d1a9451">log_components_t</a>     component,
<a name="l00381"></a>00381                  <a class="code" href="log_8h.html#a7d610232186d5b534b8bcb9081442744">log_levels_t</a>         debug,
<a name="l00382"></a>00382                  <span class="keyword">const</span> <span class="keywordtype">char</span>         * reason,
<a name="l00383"></a>00383                  <a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>      * pentry,
<a name="l00384"></a>00384                  <span class="keywordtype">void</span>               * powner,
<a name="l00385"></a>00385                  <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>  * plock)
<a name="l00386"></a>00386 {
<a name="l00387"></a>00387   <a class="code" href="log_8h.html#aa2e3d19c50b7644277f99c1d661c39bf">LogAtLevel</a>(component, debug,
<a name="l00388"></a>00388              <span class="stringliteral">&quot;%s Lock: pentry=%p, powner=%p, type=%s, start=0x%llx, end=0x%llx&quot;</span>,
<a name="l00389"></a>00389              reason,
<a name="l00390"></a>00390              pentry,
<a name="l00391"></a>00391              powner,
<a name="l00392"></a>00392              <a class="code" href="state__lock_8c.html#ab14c3d284d8c8926d94d1affda7becfe">str_lockt</a>(plock-&gt;<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a>),
<a name="l00393"></a>00393              (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>,
<a name="l00394"></a>00394              (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(plock));
<a name="l00395"></a>00395 }
<a name="l00396"></a>00396 
<a name="l00397"></a><a class="code" href="state__lock_8c.html#a570a90379b6fa100ba1c7b7955182c29">00397</a> <span class="keywordtype">void</span> <a class="code" href="sal__functions_8h.html#a570a90379b6fa100ba1c7b7955182c29">dump_all_locks</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * label)
<a name="l00398"></a>00398 {
<a name="l00399"></a>00399 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span>  <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a> *glist;
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(all_locks_mutex);
<a name="l00403"></a>00403 
<a name="l00404"></a>00404   <span class="keywordflow">if</span>(glist_empty(&amp;state_all_locks))
<a name="l00405"></a>00405     {
<a name="l00406"></a>00406       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <span class="stringliteral">&quot;All Locks are freed&quot;</span>);
<a name="l00407"></a>00407       <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(all_locks_mutex);
<a name="l00408"></a>00408       <span class="keywordflow">return</span>;
<a name="l00409"></a>00409     }
<a name="l00410"></a>00410 
<a name="l00411"></a>00411   <a class="code" href="nlm__list_8h.html#a39dd5015f511354bf29ba3cec9a3987b">glist_for_each</a>(glist, &amp;state_all_locks)
<a name="l00412"></a>00412     LogEntry(label, <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_all_locks));
<a name="l00413"></a>00413 
<a name="l00414"></a>00414   <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(all_locks_mutex);
<a name="l00415"></a>00415 <span class="preprocessor">#else</span>
<a name="l00416"></a>00416 <span class="preprocessor"></span>  <span class="keywordflow">return</span>;
<a name="l00417"></a>00417 <span class="preprocessor">#endif</span>
<a name="l00418"></a>00418 <span class="preprocessor"></span>}
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 <span class="comment">/******************************************************************************</span>
<a name="l00421"></a>00421 <span class="comment"> *</span>
<a name="l00422"></a>00422 <span class="comment"> * Functions to manage lock entries and lock list</span>
<a name="l00423"></a>00423 <span class="comment"> *</span>
<a name="l00424"></a>00424 <span class="comment"> ******************************************************************************/</span>
<a name="l00425"></a>00425 <span class="keyword">static</span> <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *create_state_lock_entry(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>      * pentry,
<a name="l00426"></a>00426                                                    <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>  * pcontext,
<a name="l00427"></a>00427                                                    <a class="code" href="structexportlist____.html">exportlist_t</a>       * pexport,
<a name="l00428"></a>00428                                                    <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8f">state_blocking_t</a>     blocked,
<a name="l00429"></a>00429                                                    <a class="code" href="structstate__owner__t.html">state_owner_t</a>      * powner,
<a name="l00430"></a>00430                                                    <a class="code" href="structstate__t.html">state_t</a>            * pstate,
<a name="l00431"></a>00431                                                    <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>  * plock)
<a name="l00432"></a>00432 {
<a name="l00433"></a>00433   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *new_entry;
<a name="l00434"></a>00434 
<a name="l00435"></a>00435   new_entry = gsh_malloc(<span class="keyword">sizeof</span>(*new_entry));
<a name="l00436"></a>00436   <span class="keywordflow">if</span>(!new_entry)
<a name="l00437"></a>00437       <span class="keywordflow">return</span> <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439   <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l00440"></a>00440                <span class="stringliteral">&quot;new_entry = %p&quot;</span>, new_entry);
<a name="l00441"></a>00441 
<a name="l00442"></a>00442   memset(new_entry, 0, <span class="keyword">sizeof</span>(*new_entry));
<a name="l00443"></a>00443 
<a name="l00444"></a>00444   <span class="keywordflow">if</span>(pthread_mutex_init(&amp;new_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a486249b507ae2a75ff43e04a9cb8bbf5">sle_mutex</a>, <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) == -1)
<a name="l00445"></a>00445     {
<a name="l00446"></a>00446       gsh_free(new_entry);
<a name="l00447"></a>00447       <span class="keywordflow">return</span> <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00448"></a>00448     }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450   new_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a4bcbf0d0f30014bab3b90583f90d5e5f">sle_ref_count</a>  = 1;
<a name="l00451"></a>00451   new_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#aab01a34cef6e6bbeea32a83e906b7f32">sle_pentry</a>     = pentry;
<a name="l00452"></a>00452   new_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a>    = blocked;
<a name="l00453"></a>00453   new_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>      = powner;
<a name="l00454"></a>00454   new_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abb0ab635935d64b79bb2a6d3ee328731">sle_state</a>      = pstate;
<a name="l00455"></a>00455   new_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a> = <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;   <span class="comment">/* will be filled in later if necessary */</span>
<a name="l00456"></a>00456   new_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>       = *plock;
<a name="l00457"></a>00457   new_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>    = pexport;
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 <span class="preprocessor">#ifdef _USE_NLM</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(powner-&gt;<a class="code" href="structstate__owner__t.html#a348f822632529b5aa366e84b1b5edeea">so_type</a> == STATE_LOCK_OWNER_NLM)
<a name="l00461"></a>00461     {
<a name="l00462"></a>00462       <span class="comment">/* Add to list of locks owned by client that powner belongs to */</span>
<a name="l00463"></a>00463       <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(powner-&gt;<a class="code" href="structstate__owner__t.html#a2952e79d65755ad25235af0d306fb0d3">so_owner</a>.so_nlm_owner.so_client-&gt;slc_nsm_client-&gt;ssc_mutex);
<a name="l00464"></a>00464 
<a name="l00465"></a>00465       glist_add_tail(&amp;powner-&gt;<a class="code" href="structstate__owner__t.html#a2952e79d65755ad25235af0d306fb0d3">so_owner</a>.so_nlm_owner.so_client-&gt;slc_nsm_client-&gt;ssc_lock_list,
<a name="l00466"></a>00466                      &amp;new_entry-&gt;sle_client_locks);
<a name="l00467"></a>00467 
<a name="l00468"></a>00468       <a class="code" href="nlm__owner_8c.html#aff2ee358f7ae57ff6d2540762b24e3ae">inc_nsm_client_ref_locked</a>(powner-&gt;<a class="code" href="structstate__owner__t.html#a2952e79d65755ad25235af0d306fb0d3">so_owner</a>.so_nlm_owner.so_client-&gt;slc_nsm_client);
<a name="l00469"></a>00469 
<a name="l00470"></a>00470       <span class="comment">/* Add to list of locks owned by export */</span>
<a name="l00471"></a>00471       <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(pexport-&gt;<a class="code" href="structexportlist____.html#a0052fa2d636dcf379935fd90ec3d9bed">exp_state_mutex</a>);
<a name="l00472"></a>00472       glist_add_tail(&amp;pexport-&gt;exp_lock_list,
<a name="l00473"></a>00473                      &amp;new_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#aab3f66300d34269d5187570052eee52e">sle_export_locks</a>);
<a name="l00474"></a>00474       <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(pexport-&gt;<a class="code" href="structexportlist____.html#a0052fa2d636dcf379935fd90ec3d9bed">exp_state_mutex</a>);
<a name="l00475"></a>00475     }
<a name="l00476"></a>00476 <span class="preprocessor">#endif</span>
<a name="l00477"></a>00477 <span class="preprocessor"></span>  <span class="comment">/* Add to list of locks owned by powner */</span>
<a name="l00478"></a>00478   <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(powner-&gt;<a class="code" href="structstate__owner__t.html#a48a1d1f3663a55fa4ee7180dfcc02238">so_mutex</a>);
<a name="l00479"></a>00479 
<a name="l00480"></a>00480   <span class="keywordflow">if</span>(powner-&gt;<a class="code" href="structstate__owner__t.html#a348f822632529b5aa366e84b1b5edeea">so_type</a> == <a class="code" href="sal__data_8h.html#aa24f9f02b90bb72f27c7349957b4d2b0acd147a77b1c77b63b902f5e13e76c9ab">STATE_LOCK_OWNER_NFSV4</a> &amp;&amp; pstate != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00481"></a>00481     {
<a name="l00482"></a>00482       glist_add_tail(&amp;pstate-&gt;<a class="code" href="structstate__t.html#ae1e2a8e1dce5ca3a43abe017b7e07c4c">state_data</a>.<a class="code" href="unionstate__data__t.html#a14300fcb7bf0be0a083e89868a89c1e6">lock</a>.<a class="code" href="structstate__lock__t.html#a7436dd87d7235291df3215c5f38b53c4">state_locklist</a>,
<a name="l00483"></a>00483                      &amp;new_entry-&gt;sle_state_locks);
<a name="l00484"></a>00484     }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486   glist_add_tail(&amp;powner-&gt;<a class="code" href="structstate__owner__t.html#a769981c093a67e98f4b8aa95bdd122ed">so_lock_list</a>, &amp;new_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a387fd4963b7fa3864806f627ea602f47">sle_owner_locks</a>);
<a name="l00487"></a>00487 
<a name="l00488"></a>00488   <a class="code" href="sal__functions_8h.html#a0f5e8266f6e939de262ee6677326057f">inc_state_owner_ref_locked</a>(powner);
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 <span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
<a name="l00491"></a>00491 <span class="preprocessor"></span>  <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(all_locks_mutex);
<a name="l00492"></a>00492 
<a name="l00493"></a>00493   glist_add_tail(&amp;state_all_locks, &amp;new_entry-&gt;sle_all_locks);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(all_locks_mutex);
<a name="l00496"></a>00496 <span class="preprocessor">#endif</span>
<a name="l00497"></a>00497 <span class="preprocessor"></span>
<a name="l00498"></a>00498   <span class="keywordflow">return</span> new_entry;
<a name="l00499"></a>00499 }
<a name="l00500"></a>00500 
<a name="l00501"></a><a class="code" href="state__lock_8c.html#ab75ff5c0bc625624c860e46714987ae6">00501</a> <span class="keyword">inline</span> <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *<a class="code" href="state__lock_8c.html#ab75ff5c0bc625624c860e46714987ae6">state_lock_entry_t_dup</a>(<a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>  * pcontext,
<a name="l00502"></a>00502                                                   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> * orig_entry)
<a name="l00503"></a>00503 {
<a name="l00504"></a>00504   <span class="keywordflow">return</span> create_state_lock_entry(orig_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#aab01a34cef6e6bbeea32a83e906b7f32">sle_pentry</a>,
<a name="l00505"></a>00505                                  pcontext,
<a name="l00506"></a>00506                                  orig_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>,
<a name="l00507"></a>00507                                  orig_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a>,
<a name="l00508"></a>00508                                  orig_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>,
<a name="l00509"></a>00509                                  orig_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abb0ab635935d64b79bb2a6d3ee328731">sle_state</a>,
<a name="l00510"></a>00510                                  &amp;orig_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>);
<a name="l00511"></a>00511 }
<a name="l00512"></a>00512 
<a name="l00513"></a><a class="code" href="state__lock_8c.html#a0385907ca0d4bed7af36c0feb8c52c33">00513</a> <span class="keywordtype">void</span> <a class="code" href="state__lock_8c.html#a0385907ca0d4bed7af36c0feb8c52c33">lock_entry_inc_ref</a>(<a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *lock_entry)
<a name="l00514"></a>00514 {
<a name="l00515"></a>00515     <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a486249b507ae2a75ff43e04a9cb8bbf5">sle_mutex</a>);
<a name="l00516"></a>00516     lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a4bcbf0d0f30014bab3b90583f90d5e5f">sle_ref_count</a>++;
<a name="l00517"></a>00517     LogEntry(<span class="stringliteral">&quot;Increment refcount&quot;</span>, lock_entry);
<a name="l00518"></a>00518     <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a486249b507ae2a75ff43e04a9cb8bbf5">sle_mutex</a>);
<a name="l00519"></a>00519 }
<a name="l00520"></a>00520 
<a name="l00521"></a><a class="code" href="state__lock_8c.html#aafed8460a8729acbd1e617f95606550e">00521</a> <span class="keywordtype">void</span> <a class="code" href="state__lock_8c.html#aafed8460a8729acbd1e617f95606550e">lock_entry_dec_ref</a>(<a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *lock_entry)
<a name="l00522"></a>00522 {
<a name="l00523"></a>00523   bool_t to_free = <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00524"></a>00524 
<a name="l00525"></a>00525   <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a486249b507ae2a75ff43e04a9cb8bbf5">sle_mutex</a>);
<a name="l00526"></a>00526 
<a name="l00527"></a>00527   lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a4bcbf0d0f30014bab3b90583f90d5e5f">sle_ref_count</a>--;
<a name="l00528"></a>00528 
<a name="l00529"></a>00529     LogEntry(<span class="stringliteral">&quot;Decrement refcount&quot;</span>, lock_entry);
<a name="l00530"></a>00530 
<a name="l00531"></a>00531   <span class="keywordflow">if</span>(!lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a4bcbf0d0f30014bab3b90583f90d5e5f">sle_ref_count</a>)
<a name="l00532"></a>00532     {
<a name="l00533"></a>00533       <span class="comment">/*</span>
<a name="l00534"></a>00534 <span class="comment">       * We should already be removed from the lock_list</span>
<a name="l00535"></a>00535 <span class="comment">       * So we can free the lock_entry without any locking</span>
<a name="l00536"></a>00536 <span class="comment">       */</span>
<a name="l00537"></a>00537       to_free = <a class="code" href="HashTable_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540   <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a486249b507ae2a75ff43e04a9cb8bbf5">sle_mutex</a>);
<a name="l00541"></a>00541 
<a name="l00542"></a>00542   <span class="keywordflow">if</span>(to_free)
<a name="l00543"></a>00543     {
<a name="l00544"></a>00544       LogEntry(<span class="stringliteral">&quot;Freeing&quot;</span>, lock_entry);
<a name="l00545"></a>00545 
<a name="l00546"></a>00546 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l00547"></a>00547 <span class="preprocessor"></span>      <span class="comment">/* Release block data if present */</span>
<a name="l00548"></a>00548       <span class="keywordflow">if</span>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a> != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00549"></a>00549         {
<a name="l00550"></a>00550           memset(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>, 0, <span class="keyword">sizeof</span>(*(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>)));
<a name="l00551"></a>00551           gsh_free(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>);
<a name="l00552"></a>00552         }
<a name="l00553"></a>00553 <span class="preprocessor">#endif</span>
<a name="l00554"></a>00554 <span class="preprocessor"></span><span class="preprocessor">#ifdef _DEBUG_MEMLEAKS</span>
<a name="l00555"></a>00555 <span class="preprocessor"></span>      <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(all_locks_mutex);
<a name="l00556"></a>00556       glist_del(&amp;lock_entry-&gt;sle_all_locks);
<a name="l00557"></a>00557       <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(all_locks_mutex);
<a name="l00558"></a>00558 <span class="preprocessor">#endif</span>
<a name="l00559"></a>00559 <span class="preprocessor"></span>
<a name="l00560"></a>00560       memset(lock_entry, 0, <span class="keyword">sizeof</span>(*lock_entry));
<a name="l00561"></a>00561       gsh_free(lock_entry);
<a name="l00562"></a>00562     }
<a name="l00563"></a>00563 }
<a name="l00564"></a>00564 
<a name="l00565"></a>00565 <span class="keyword">static</span> <span class="keywordtype">void</span> remove_from_locklist(<a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>   * lock_entry)
<a name="l00566"></a>00566 {
<a name="l00567"></a>00567   <a class="code" href="structstate__owner__t.html">state_owner_t</a> * powner = lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>;
<a name="l00568"></a>00568 
<a name="l00569"></a>00569   LogEntry(<span class="stringliteral">&quot;Removing&quot;</span>, lock_entry);
<a name="l00570"></a>00570 
<a name="l00571"></a>00571   <span class="comment">/*</span>
<a name="l00572"></a>00572 <span class="comment">   * If some other thread is holding a reference to this nlm_lock_entry</span>
<a name="l00573"></a>00573 <span class="comment">   * don&#39;t free the structure. But drop from the lock list</span>
<a name="l00574"></a>00574 <span class="comment">   */</span>
<a name="l00575"></a>00575   <span class="keywordflow">if</span>(powner != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00576"></a>00576     {
<a name="l00577"></a>00577 <span class="preprocessor">#ifdef _USE_NLM</span>
<a name="l00578"></a>00578 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(powner-&gt;<a class="code" href="structstate__owner__t.html#a348f822632529b5aa366e84b1b5edeea">so_type</a> == STATE_LOCK_OWNER_NLM)
<a name="l00579"></a>00579         {
<a name="l00580"></a>00580           <span class="comment">/* Remove from list of locks owned by client that powner belongs to */</span>
<a name="l00581"></a>00581           <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(powner-&gt;<a class="code" href="structstate__owner__t.html#a2952e79d65755ad25235af0d306fb0d3">so_owner</a>.so_nlm_owner.so_client-&gt;slc_nsm_client-&gt;ssc_mutex);
<a name="l00582"></a>00582 
<a name="l00583"></a>00583           glist_del(&amp;lock_entry-&gt;sle_client_locks);
<a name="l00584"></a>00584 
<a name="l00585"></a>00585           <a class="code" href="nlm__owner_8c.html#a9aa67f3a1e15df9e7a2aa062943c3246">dec_nsm_client_ref_locked</a>(powner-&gt;<a class="code" href="structstate__owner__t.html#a2952e79d65755ad25235af0d306fb0d3">so_owner</a>.so_nlm_owner.so_client-&gt;slc_nsm_client);
<a name="l00586"></a>00586 
<a name="l00587"></a>00587           <span class="comment">/* Remove from list of locks owned by export */</span>
<a name="l00588"></a>00588           <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>-&gt;<a class="code" href="structexportlist____.html#a0052fa2d636dcf379935fd90ec3d9bed">exp_state_mutex</a>);
<a name="l00589"></a>00589           glist_del(&amp;lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#aab3f66300d34269d5187570052eee52e">sle_export_locks</a>);
<a name="l00590"></a>00590           <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>-&gt;<a class="code" href="structexportlist____.html#a0052fa2d636dcf379935fd90ec3d9bed">exp_state_mutex</a>);
<a name="l00591"></a>00591         }
<a name="l00592"></a>00592 <span class="preprocessor">#endif</span>
<a name="l00593"></a>00593 <span class="preprocessor"></span>
<a name="l00594"></a>00594       <span class="comment">/* Remove from list of locks owned by powner */</span>
<a name="l00595"></a>00595       <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(powner-&gt;<a class="code" href="structstate__owner__t.html#a48a1d1f3663a55fa4ee7180dfcc02238">so_mutex</a>);
<a name="l00596"></a>00596 
<a name="l00597"></a>00597       <span class="keywordflow">if</span>(powner-&gt;<a class="code" href="structstate__owner__t.html#a348f822632529b5aa366e84b1b5edeea">so_type</a> == <a class="code" href="sal__data_8h.html#aa24f9f02b90bb72f27c7349957b4d2b0acd147a77b1c77b63b902f5e13e76c9ab">STATE_LOCK_OWNER_NFSV4</a>)
<a name="l00598"></a>00598         {
<a name="l00599"></a>00599           glist_del(&amp;lock_entry-&gt;sle_state_locks);
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602       glist_del(&amp;lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a387fd4963b7fa3864806f627ea602f47">sle_owner_locks</a>);
<a name="l00603"></a>00603 
<a name="l00604"></a>00604       <a class="code" href="sal__functions_8h.html#a92d4e966d9abde529120aab99f932fda">dec_state_owner_ref_locked</a>(powner);
<a name="l00605"></a>00605     }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a> = <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00608"></a>00608   glist_del(&amp;lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#ae87ceb436fd9f2ee0fbc19f454d74d52">sle_list</a>);
<a name="l00609"></a>00609   <a class="code" href="state__lock_8c.html#aafed8460a8729acbd1e617f95606550e">lock_entry_dec_ref</a>(lock_entry);
<a name="l00610"></a>00610 }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 <span class="keyword">static</span> <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *get_overlapping_entry(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>     * pentry,
<a name="l00613"></a>00613                                                  <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a> * pcontext,
<a name="l00614"></a>00614                                                  <a class="code" href="structstate__owner__t.html">state_owner_t</a>     * powner,
<a name="l00615"></a>00615                                                  <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a> * plock)
<a name="l00616"></a>00616 {
<a name="l00617"></a>00617   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a> *glist;
<a name="l00618"></a>00618   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *found_entry = <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00619"></a>00619   <a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a> found_entry_end, plock_end = <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(plock);
<a name="l00620"></a>00620 
<a name="l00621"></a>00621   <a class="code" href="nlm__list_8h.html#a39dd5015f511354bf29ba3cec9a3987b">glist_for_each</a>(glist, &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list)
<a name="l00622"></a>00622     {
<a name="l00623"></a>00623       found_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l00624"></a>00624 
<a name="l00625"></a>00625       LogEntry(<span class="stringliteral">&quot;Checking&quot;</span>, found_entry);
<a name="l00626"></a>00626 
<a name="l00627"></a>00627       <span class="comment">/* Skip blocked or cancelled locks */</span>
<a name="l00628"></a>00628       <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> == <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa1f8b0da78f5ae271f0ff4c1ed4faf586">STATE_NLM_BLOCKING</a> ||
<a name="l00629"></a>00629          found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> == <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fafdc4ecdcd48b788e6b4ceb21e112dbb4">STATE_NFSV4_BLOCKING</a> ||
<a name="l00630"></a>00630          found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> == <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fac759db4905b8050e53794a5664963f52">STATE_CANCELED</a>)
<a name="l00631"></a>00631           <span class="keywordflow">continue</span>;
<a name="l00632"></a>00632 
<a name="l00633"></a>00633       found_entry_end = <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(&amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>);
<a name="l00634"></a>00634 
<a name="l00635"></a>00635       <span class="keywordflow">if</span>((found_entry_end &gt;= plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>) &amp;&amp;
<a name="l00636"></a>00636          (found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> &lt;= plock_end))
<a name="l00637"></a>00637         {
<a name="l00638"></a>00638           <span class="comment">/* lock overlaps see if we can allow</span>
<a name="l00639"></a>00639 <span class="comment">           * allow if neither lock is exclusive or the owner is the same</span>
<a name="l00640"></a>00640 <span class="comment">           */</span>
<a name="l00641"></a>00641           <span class="keywordflow">if</span>((found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a> == <a class="code" href="fsal__types_8h.html#aab76e308a0e07a7fcb4f4182ca3c098ca26e942e5ccc850086303fb166d2e1624">FSAL_LOCK_W</a> ||
<a name="l00642"></a>00642               plock-&gt;<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a> == <a class="code" href="fsal__types_8h.html#aab76e308a0e07a7fcb4f4182ca3c098ca26e942e5ccc850086303fb166d2e1624">FSAL_LOCK_W</a>) &amp;&amp;
<a name="l00643"></a>00643              <a class="code" href="sal__functions_8h.html#aafafe1a716e741dd5d3a2b3f579ddb94">different_owners</a>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>, powner)
<a name="l00644"></a>00644              )
<a name="l00645"></a>00645             {
<a name="l00646"></a>00646               <span class="comment">/* found a conflicting lock, return it */</span>
<a name="l00647"></a>00647               <span class="keywordflow">return</span> found_entry;
<a name="l00648"></a>00648             }
<a name="l00649"></a>00649         }
<a name="l00650"></a>00650     }
<a name="l00651"></a>00651 
<a name="l00652"></a>00652   <span class="keywordflow">return</span> <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00653"></a>00653 }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655 <span class="comment">/* We need to iterate over the full lock list and remove</span>
<a name="l00656"></a>00656 <span class="comment"> * any mapping entry. And l_offset = 0 and sle_lock.lock_length = 0 lock_entry</span>
<a name="l00657"></a>00657 <span class="comment"> * implies remove all entries</span>
<a name="l00658"></a>00658 <span class="comment"> */</span>
<a name="l00659"></a>00659 <span class="keyword">static</span> <span class="keywordtype">void</span> merge_lock_entry(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l00660"></a>00660                              <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l00661"></a>00661                              <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>   * lock_entry)
<a name="l00662"></a>00662 {
<a name="l00663"></a>00663   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> * check_entry;
<a name="l00664"></a>00664   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> * check_entry_right;
<a name="l00665"></a>00665   <a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a>             check_entry_end;
<a name="l00666"></a>00666   <a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a>             lock_entry_end;
<a name="l00667"></a>00667   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a>  * glist;
<a name="l00668"></a>00668   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a>  * glistn;
<a name="l00669"></a>00669 
<a name="l00670"></a>00670   <span class="comment">/* lock_entry might be STATE_NON_BLOCKING or STATE_GRANTING */</span>
<a name="l00671"></a>00671 
<a name="l00672"></a>00672   <a class="code" href="nlm__list_8h.html#aa69d13cb8dd7170f99c92dddccde8ebe">glist_for_each_safe</a>(glist, glistn, &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list)
<a name="l00673"></a>00673     {
<a name="l00674"></a>00674       check_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l00675"></a>00675 
<a name="l00676"></a>00676       <span class="comment">/* Skip entry being merged - it could be in the list */</span>
<a name="l00677"></a>00677       <span class="keywordflow">if</span>(check_entry == lock_entry)
<a name="l00678"></a>00678         <span class="keywordflow">continue</span>;
<a name="l00679"></a>00679 
<a name="l00680"></a>00680       <span class="keywordflow">if</span>(<a class="code" href="sal__functions_8h.html#aafafe1a716e741dd5d3a2b3f579ddb94">different_owners</a>(check_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>, lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>))
<a name="l00681"></a>00681         <span class="keywordflow">continue</span>;
<a name="l00682"></a>00682 
<a name="l00683"></a>00683       <span class="comment">/* Only merge fully granted locks */</span>
<a name="l00684"></a>00684       <span class="keywordflow">if</span>(check_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> != <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8facf0a49c1e4b5d2ab379c0b9c61df625d">STATE_NON_BLOCKING</a>)
<a name="l00685"></a>00685         <span class="keywordflow">continue</span>;
<a name="l00686"></a>00686 
<a name="l00687"></a>00687       check_entry_end = <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(&amp;check_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>);
<a name="l00688"></a>00688       lock_entry_end  = <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(&amp;lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>);
<a name="l00689"></a>00689 
<a name="l00690"></a>00690       <span class="keywordflow">if</span>((check_entry_end + 1) &lt; lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>)
<a name="l00691"></a>00691         <span class="comment">/* nothing to merge */</span>
<a name="l00692"></a>00692         <span class="keywordflow">continue</span>;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694       <span class="keywordflow">if</span>((lock_entry_end + 1) &lt; check_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>)
<a name="l00695"></a>00695         <span class="comment">/* nothing to merge */</span>
<a name="l00696"></a>00696         <span class="keywordflow">continue</span>;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698       <span class="comment">/* Need to handle locks of different types differently, may split an old lock.</span>
<a name="l00699"></a>00699 <span class="comment">       * If new lock totally overlaps old lock, the new lock will replace the old</span>
<a name="l00700"></a>00700 <span class="comment">       * lock so no special work to be done.</span>
<a name="l00701"></a>00701 <span class="comment">       */</span>
<a name="l00702"></a>00702       <span class="keywordflow">if</span>((check_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a> != lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a>) &amp;&amp;
<a name="l00703"></a>00703          ((lock_entry_end &lt; check_entry_end) ||
<a name="l00704"></a>00704           (check_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> &lt; lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>)))
<a name="l00705"></a>00705         {
<a name="l00706"></a>00706           <span class="keywordflow">if</span>(lock_entry_end &lt; check_entry_end &amp;&amp;
<a name="l00707"></a>00707              check_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> &lt; lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>)
<a name="l00708"></a>00708             {
<a name="l00709"></a>00709               <span class="comment">/* Need to split old lock */</span>
<a name="l00710"></a>00710               check_entry_right = <a class="code" href="state__lock_8c.html#ab75ff5c0bc625624c860e46714987ae6">state_lock_entry_t_dup</a>(pcontext, check_entry);
<a name="l00711"></a>00711               <span class="keywordflow">if</span>(check_entry_right == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00712"></a>00712                 {
<a name="l00713"></a>00713                   <span class="comment">// TODO FSF: OOPS....</span>
<a name="l00714"></a>00714                   <span class="comment">// Leave old lock in place, it may cause false conflicts, but should eventually be released</span>
<a name="l00715"></a>00715                   <a class="code" href="log_8h.html#a3cf3c22fac6bb9871e25007551caeb13">LogMajor</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l00716"></a>00716                            <span class="stringliteral">&quot;Memory allocation failure during lock upgrade/downgrade&quot;</span>);
<a name="l00717"></a>00717                   <span class="keywordflow">continue</span>;
<a name="l00718"></a>00718                 }
<a name="l00719"></a>00719               glist_add_tail(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list, &amp;(check_entry_right-&gt;<a class="code" href="structstate__lock__entry__t.html#ae87ceb436fd9f2ee0fbc19f454d74d52">sle_list</a>));
<a name="l00720"></a>00720             }
<a name="l00721"></a>00721           <span class="keywordflow">else</span>
<a name="l00722"></a>00722             {
<a name="l00723"></a>00723               <span class="comment">/* No split, just shrink, make the logic below work on original lock */</span>
<a name="l00724"></a>00724               check_entry_right = check_entry;
<a name="l00725"></a>00725             }
<a name="l00726"></a>00726           <span class="keywordflow">if</span>(lock_entry_end &lt; check_entry_end)
<a name="l00727"></a>00727             {
<a name="l00728"></a>00728               <span class="comment">/* Need to shrink old lock from beginning (right lock if split) */</span>
<a name="l00729"></a>00729               LogEntry(<span class="stringliteral">&quot;Merge shrinking right&quot;</span>, check_entry_right);
<a name="l00730"></a>00730               check_entry_right-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>  = lock_entry_end + 1;
<a name="l00731"></a>00731               check_entry_right-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a> = check_entry_end - lock_entry_end;
<a name="l00732"></a>00732               LogEntry(<span class="stringliteral">&quot;Merge shrunk right&quot;</span>, check_entry_right);
<a name="l00733"></a>00733               <span class="keywordflow">continue</span>;
<a name="l00734"></a>00734             }
<a name="l00735"></a>00735           <span class="keywordflow">if</span>(check_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> &lt; lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>)
<a name="l00736"></a>00736             {
<a name="l00737"></a>00737               <span class="comment">/* Need to shrink old lock from end (left lock if split) */</span>
<a name="l00738"></a>00738               LogEntry(<span class="stringliteral">&quot;Merge shrinking left&quot;</span>, check_entry);
<a name="l00739"></a>00739               check_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a> = lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> - check_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>;
<a name="l00740"></a>00740               LogEntry(<span class="stringliteral">&quot;Merge shrunk left&quot;</span>, check_entry);
<a name="l00741"></a>00741               <span class="keywordflow">continue</span>;
<a name="l00742"></a>00742             }
<a name="l00743"></a>00743           <span class="comment">/* Done splitting/shrinking old lock */</span>
<a name="l00744"></a>00744           <span class="keywordflow">continue</span>;
<a name="l00745"></a>00745         }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747       <span class="comment">/* check_entry touches or overlaps lock_entry, expand lock_entry */</span>
<a name="l00748"></a>00748       <span class="keywordflow">if</span>(lock_entry_end &lt; check_entry_end)
<a name="l00749"></a>00749         <span class="comment">/* Expand end of lock_entry */</span>
<a name="l00750"></a>00750         lock_entry_end = check_entry_end;
<a name="l00751"></a>00751 
<a name="l00752"></a>00752       <span class="keywordflow">if</span>(check_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> &lt; lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>)
<a name="l00753"></a>00753         <span class="comment">/* Expand start of lock_entry */</span>
<a name="l00754"></a>00754         lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> = check_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756       <span class="comment">/* Compute new lock length */</span>
<a name="l00757"></a>00757       lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a> = lock_entry_end - lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> + 1;
<a name="l00758"></a>00758 
<a name="l00759"></a>00759       <span class="comment">/* Remove merged entry */</span>
<a name="l00760"></a>00760       LogEntry(<span class="stringliteral">&quot;Merged&quot;</span>, lock_entry);
<a name="l00761"></a>00761       LogEntry(<span class="stringliteral">&quot;Merging removing&quot;</span>, check_entry);
<a name="l00762"></a>00762       remove_from_locklist(check_entry);
<a name="l00763"></a>00763     }
<a name="l00764"></a>00764 }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766 <span class="keyword">static</span> <span class="keywordtype">void</span> free_list(<span class="keyword">struct</span> <a class="code" href="structglist__head.html">glist_head</a>    * list)
<a name="l00767"></a>00767 {
<a name="l00768"></a>00768   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *found_entry;
<a name="l00769"></a>00769   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a> *glist, *glistn;
<a name="l00770"></a>00770 
<a name="l00771"></a>00771   <a class="code" href="nlm__list_8h.html#aa69d13cb8dd7170f99c92dddccde8ebe">glist_for_each_safe</a>(glist, glistn, list)
<a name="l00772"></a>00772     {
<a name="l00773"></a>00773       found_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l00774"></a>00774 
<a name="l00775"></a>00775       remove_from_locklist(found_entry);
<a name="l00776"></a>00776     }
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 <span class="comment">/* Subtract a lock from a lock entry, placing any remaining bits into the split list. */</span>
<a name="l00780"></a>00780 <span class="keyword">static</span> bool_t subtract_lock_from_entry(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l00781"></a>00781                                        <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l00782"></a>00782                                        <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>   * found_entry,
<a name="l00783"></a>00783                                        <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * plock,
<a name="l00784"></a>00784                                        <span class="keyword">struct</span> <a class="code" href="structglist__head.html">glist_head</a>    * split_list,
<a name="l00785"></a>00785                                        <span class="keyword">struct</span> <a class="code" href="structglist__head.html">glist_head</a>    * remove_list,
<a name="l00786"></a>00786                                        <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>       * pstatus)
<a name="l00787"></a>00787 {
<a name="l00788"></a>00788   <a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a> found_entry_end = <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(&amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>);
<a name="l00789"></a>00789   <a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a> plock_end = <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(plock);
<a name="l00790"></a>00790   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *found_entry_left = <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00791"></a>00791   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *found_entry_right = <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l00792"></a>00792 
<a name="l00793"></a>00793   *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l00794"></a>00794 
<a name="l00795"></a>00795   <span class="keywordflow">if</span>(plock_end &lt; found_entry-&gt;sle_lock.lock_start)
<a name="l00796"></a>00796     <span class="comment">/* nothing to split */</span>
<a name="l00797"></a>00797     <span class="keywordflow">return</span> <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00798"></a>00798 
<a name="l00799"></a>00799   <span class="keywordflow">if</span>(found_entry_end &lt; plock-&gt;lock_start)
<a name="l00800"></a>00800     <span class="comment">/* nothing to split */</span>
<a name="l00801"></a>00801     <span class="keywordflow">return</span> <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00802"></a>00802 
<a name="l00803"></a>00803   <span class="keywordflow">if</span>((plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> &lt;= found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>) &amp;&amp;
<a name="l00804"></a>00804      plock_end &gt;= found_entry_end)
<a name="l00805"></a>00805     {
<a name="l00806"></a>00806       <span class="comment">/* Fully overlap */</span>
<a name="l00807"></a>00807       LogEntry(<span class="stringliteral">&quot;Remove Complete&quot;</span>, found_entry);
<a name="l00808"></a>00808       <span class="keywordflow">goto</span> complete_remove;
<a name="l00809"></a>00809     }
<a name="l00810"></a>00810 
<a name="l00811"></a>00811   LogEntry(<span class="stringliteral">&quot;Split&quot;</span>, found_entry);
<a name="l00812"></a>00812 
<a name="l00813"></a>00813   <span class="comment">/* Delete the old entry and add one or two new entries */</span>
<a name="l00814"></a>00814   <span class="keywordflow">if</span>(plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> &gt; found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>)
<a name="l00815"></a>00815     {
<a name="l00816"></a>00816       found_entry_left = <a class="code" href="state__lock_8c.html#ab75ff5c0bc625624c860e46714987ae6">state_lock_entry_t_dup</a>(pcontext, found_entry);
<a name="l00817"></a>00817       <span class="keywordflow">if</span>(found_entry_left == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00818"></a>00818         {
<a name="l00819"></a>00819           free_list(split_list);
<a name="l00820"></a>00820           *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba83de6e519398c6a0377256b70f1d58fc">STATE_MALLOC_ERROR</a>;
<a name="l00821"></a>00821           <span class="keywordflow">return</span> <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00822"></a>00822         }
<a name="l00823"></a>00823 
<a name="l00824"></a>00824       found_entry_left-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a> = plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> - found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>;
<a name="l00825"></a>00825       LogEntry(<span class="stringliteral">&quot;Left split&quot;</span>, found_entry_left);
<a name="l00826"></a>00826       glist_add_tail(split_list, &amp;(found_entry_left-&gt;<a class="code" href="structstate__lock__entry__t.html#ae87ceb436fd9f2ee0fbc19f454d74d52">sle_list</a>));
<a name="l00827"></a>00827     }
<a name="l00828"></a>00828 
<a name="l00829"></a>00829   <span class="keywordflow">if</span>(plock_end &lt; found_entry_end)
<a name="l00830"></a>00830     {
<a name="l00831"></a>00831       found_entry_right = <a class="code" href="state__lock_8c.html#ab75ff5c0bc625624c860e46714987ae6">state_lock_entry_t_dup</a>(pcontext, found_entry);
<a name="l00832"></a>00832       <span class="keywordflow">if</span>(found_entry_right == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00833"></a>00833         {
<a name="l00834"></a>00834           free_list(split_list);
<a name="l00835"></a>00835           *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba83de6e519398c6a0377256b70f1d58fc">STATE_MALLOC_ERROR</a>;
<a name="l00836"></a>00836           <span class="keywordflow">return</span> <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00837"></a>00837         }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839       found_entry_right-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>  = plock_end + 1;
<a name="l00840"></a>00840       found_entry_right-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a> = found_entry_end - plock_end;
<a name="l00841"></a>00841       LogEntry(<span class="stringliteral">&quot;Right split&quot;</span>, found_entry_right);
<a name="l00842"></a>00842       glist_add_tail(split_list, &amp;(found_entry_right-&gt;<a class="code" href="structstate__lock__entry__t.html#ae87ceb436fd9f2ee0fbc19f454d74d52">sle_list</a>));
<a name="l00843"></a>00843     }
<a name="l00844"></a>00844 
<a name="l00845"></a>00845 complete_remove:
<a name="l00846"></a>00846 
<a name="l00847"></a>00847   <span class="comment">/* Remove the lock from the list it&#39;s on and put it on the remove_list */</span>
<a name="l00848"></a>00848   glist_del(&amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#ae87ceb436fd9f2ee0fbc19f454d74d52">sle_list</a>);
<a name="l00849"></a>00849   glist_add_tail(remove_list, &amp;(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#ae87ceb436fd9f2ee0fbc19f454d74d52">sle_list</a>));
<a name="l00850"></a>00850 
<a name="l00851"></a>00851   <span class="keywordflow">return</span> <a class="code" href="HashTable_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00852"></a>00852 }
<a name="l00853"></a>00853 
<a name="l00854"></a>00854 <span class="comment">/* Subtract a lock from a list of locks, possibly splitting entries in the list. */</span>
<a name="l00855"></a>00855 <span class="keyword">static</span> bool_t subtract_lock_from_list(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l00856"></a>00856                                       <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l00857"></a>00857                                       <a class="code" href="structstate__owner__t.html">state_owner_t</a>        * powner,
<a name="l00858"></a>00858                                       <a class="code" href="structstate__t.html">state_t</a>              * pstate,
<a name="l00859"></a>00859                                       <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * plock,
<a name="l00860"></a>00860                                       <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>       * pstatus,
<a name="l00861"></a>00861                                       <span class="keyword">struct</span> <a class="code" href="structglist__head.html">glist_head</a>    * list)
<a name="l00862"></a>00862 {
<a name="l00863"></a>00863   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *found_entry;
<a name="l00864"></a>00864   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a> split_lock_list, remove_list;
<a name="l00865"></a>00865   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a> *glist, *glistn;
<a name="l00866"></a>00866   bool_t rc = <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00867"></a>00867 
<a name="l00868"></a>00868   init_glist(&amp;split_lock_list);
<a name="l00869"></a>00869   init_glist(&amp;remove_list);
<a name="l00870"></a>00870 
<a name="l00871"></a>00871   *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l00872"></a>00872   <a class="code" href="nlm__list_8h.html#aa69d13cb8dd7170f99c92dddccde8ebe">glist_for_each_safe</a>(glist, glistn, list)
<a name="l00873"></a>00873     {
<a name="l00874"></a>00874       found_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l00875"></a>00875 
<a name="l00876"></a>00876       <span class="keywordflow">if</span>(powner != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> &amp;&amp; <a class="code" href="sal__functions_8h.html#aafafe1a716e741dd5d3a2b3f579ddb94">different_owners</a>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>, powner))
<a name="l00877"></a>00877         <span class="keywordflow">continue</span>;
<a name="l00878"></a>00878 
<a name="l00879"></a>00879       <span class="comment">/* Only care about granted locks */</span>
<a name="l00880"></a>00880       <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> != <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8facf0a49c1e4b5d2ab379c0b9c61df625d">STATE_NON_BLOCKING</a>)
<a name="l00881"></a>00881         <span class="keywordflow">continue</span>;
<a name="l00882"></a>00882 
<a name="l00883"></a>00883 
<a name="l00884"></a>00884 <span class="preprocessor">#ifdef _USE_NLM</span>
<a name="l00885"></a>00885 <span class="preprocessor"></span>      <span class="comment">/* Skip locks owned by this NLM state.</span>
<a name="l00886"></a>00886 <span class="comment">       * This protects NLM locks from the current iteration of an NLM</span>
<a name="l00887"></a>00887 <span class="comment">       * client from being released by SM_NOTIFY.</span>
<a name="l00888"></a>00888 <span class="comment">       */</span>
<a name="l00889"></a>00889       <span class="keywordflow">if</span>(pstate != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> &amp;&amp;
<a name="l00890"></a>00890          <a class="code" href="state__lock_8c.html#ae3f90b2b0f41f7eff5fef21dde258371">lock_owner_is_nlm</a>(found_entry) &amp;&amp;
<a name="l00891"></a>00891          found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abb0ab635935d64b79bb2a6d3ee328731">sle_state</a> == pstate)
<a name="l00892"></a>00892         <span class="keywordflow">continue</span>;
<a name="l00893"></a>00893 <span class="preprocessor">#endif</span>
<a name="l00894"></a>00894 <span class="preprocessor"></span>
<a name="l00895"></a>00895       <span class="comment">/*</span>
<a name="l00896"></a>00896 <span class="comment">       * We have matched owner.</span>
<a name="l00897"></a>00897 <span class="comment">       * Even though we are taking a reference to found_entry, we</span>
<a name="l00898"></a>00898 <span class="comment">       * don&#39;t inc the ref count because we want to drop the lock entry.</span>
<a name="l00899"></a>00899 <span class="comment">       */</span>
<a name="l00900"></a>00900       rc |= subtract_lock_from_entry(pentry,
<a name="l00901"></a>00901                                      pcontext,
<a name="l00902"></a>00902                                      found_entry,
<a name="l00903"></a>00903                                      plock,
<a name="l00904"></a>00904                                      &amp;split_lock_list,
<a name="l00905"></a>00905                                      &amp;remove_list,
<a name="l00906"></a>00906                                      pstatus);
<a name="l00907"></a>00907       <span class="keywordflow">if</span>(*pstatus != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l00908"></a>00908         {
<a name="l00909"></a>00909           <span class="comment">/* We ran out of memory while splitting, deal with it outside loop */</span>
<a name="l00910"></a>00910           <span class="keywordflow">break</span>;
<a name="l00911"></a>00911         }
<a name="l00912"></a>00912     }
<a name="l00913"></a>00913 
<a name="l00914"></a>00914   <span class="keywordflow">if</span>(*pstatus != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l00915"></a>00915     {
<a name="l00916"></a>00916       <span class="comment">/* We ran out of memory while splitting. split_lock_list has been freed.</span>
<a name="l00917"></a>00917 <span class="comment">       * For each entry on the remove_list, put it back on the list.</span>
<a name="l00918"></a>00918 <span class="comment">       */</span>
<a name="l00919"></a>00919       <a class="code" href="log_8h.html#aa7aee8ec65b5baafb430f8d2a7588d53">LogDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l00920"></a>00920                <span class="stringliteral">&quot;Failed %s&quot;</span>,
<a name="l00921"></a>00921                <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(*pstatus));
<a name="l00922"></a>00922       <a class="code" href="nlm__list_8h.html#aa69d13cb8dd7170f99c92dddccde8ebe">glist_for_each_safe</a>(glist, glistn, &amp;remove_list)
<a name="l00923"></a>00923         {
<a name="l00924"></a>00924           found_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l00925"></a>00925           glist_del(&amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#ae87ceb436fd9f2ee0fbc19f454d74d52">sle_list</a>);
<a name="l00926"></a>00926           glist_add_tail(list, &amp;(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#ae87ceb436fd9f2ee0fbc19f454d74d52">sle_list</a>));
<a name="l00927"></a>00927         }
<a name="l00928"></a>00928     }
<a name="l00929"></a>00929   <span class="keywordflow">else</span>
<a name="l00930"></a>00930     {
<a name="l00931"></a>00931       <span class="comment">/* free the enttries on the remove_list*/</span>
<a name="l00932"></a>00932       free_list(&amp;remove_list);
<a name="l00933"></a>00933 
<a name="l00934"></a>00934       <span class="comment">/* now add the split lock list */</span>
<a name="l00935"></a>00935       glist_add_list_tail(list, &amp;split_lock_list);
<a name="l00936"></a>00936     }
<a name="l00937"></a>00937 
<a name="l00938"></a>00938   <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l00939"></a>00939                <span class="stringliteral">&quot;List of all locks for pentry=%p returning %d&quot;</span>,
<a name="l00940"></a>00940                pentry, (<span class="keywordtype">int</span>) rc);
<a name="l00941"></a>00941 
<a name="l00942"></a>00942   <span class="keywordflow">return</span> rc;
<a name="l00943"></a>00943 }
<a name="l00944"></a>00944 
<a name="l00945"></a>00945 <span class="keyword">static</span> <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> subtract_list_from_list(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l00946"></a>00946                                               <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l00947"></a>00947                                               <span class="keyword">struct</span> <a class="code" href="structglist__head.html">glist_head</a>    * target,
<a name="l00948"></a>00948                                               <span class="keyword">struct</span> <a class="code" href="structglist__head.html">glist_head</a>    * source,
<a name="l00949"></a>00949                                               <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>       * pstatus)
<a name="l00950"></a>00950 {
<a name="l00951"></a>00951   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> *found_entry;
<a name="l00952"></a>00952   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a> *glist, *glistn;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954   *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l00955"></a>00955 
<a name="l00956"></a>00956   <a class="code" href="nlm__list_8h.html#aa69d13cb8dd7170f99c92dddccde8ebe">glist_for_each_safe</a>(glist, glistn, source)
<a name="l00957"></a>00957     {
<a name="l00958"></a>00958       found_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l00959"></a>00959 
<a name="l00960"></a>00960       subtract_lock_from_list(pentry,
<a name="l00961"></a>00961                               pcontext,
<a name="l00962"></a>00962                               <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l00963"></a>00963                               <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l00964"></a>00964                               &amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>,
<a name="l00965"></a>00965                               pstatus,
<a name="l00966"></a>00966                               target);
<a name="l00967"></a>00967       <span class="keywordflow">if</span>(*pstatus != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l00968"></a>00968         <span class="keywordflow">break</span>;
<a name="l00969"></a>00969     }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971   <span class="keywordflow">return</span> *pstatus;
<a name="l00972"></a>00972 }
<a name="l00973"></a>00973 
<a name="l00974"></a>00974 <span class="comment">/******************************************************************************</span>
<a name="l00975"></a>00975 <span class="comment"> *</span>
<a name="l00976"></a>00976 <span class="comment"> * Implement hash table to hash blocked lock entries by cookie</span>
<a name="l00977"></a>00977 <span class="comment"> *</span>
<a name="l00978"></a>00978 <span class="comment"> ******************************************************************************/</span>
<a name="l00979"></a>00979 
<a name="l00980"></a>00980 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l00981"></a>00981 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> grant_blocked_locks(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l00982"></a>00982                                 <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext);
<a name="l00983"></a>00983 
<a name="l00984"></a>00984 <span class="keywordtype">int</span> <a class="code" href="sal__functions_8h.html#af55a980d426ac2729a2ec5e558302d84">display_lock_cookie_key</a>(<a class="code" href="structhash__buff.html">hash_buffer_t</a> * pbuff, <span class="keywordtype">char</span> *str)
<a name="l00985"></a>00985 {
<a name="l00986"></a>00986   <span class="keywordflow">return</span> <a class="code" href="sal__functions_8h.html#a4ac7c8d8d01b567b3a288a79a2b65709">DisplayOpaqueValue</a>((<span class="keywordtype">char</span> *)pbuff-&gt;<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a>, pbuff-&gt;<a class="code" href="structhash__buff.html#aae02d0ce42b7fda47c6f9a3138fce7b3">len</a>, str);
<a name="l00987"></a>00987 }
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 <span class="keywordtype">int</span> display_lock_cookie_entry(state_cookie_entry_t * he, <span class="keywordtype">char</span> * str)
<a name="l00990"></a>00990 {
<a name="l00991"></a>00991   <span class="keywordtype">char</span> *tmp = str;
<a name="l00992"></a>00992 
<a name="l00993"></a>00993   tmp += sprintf(tmp, <span class="stringliteral">&quot;%p: cookie &quot;</span>, he);
<a name="l00994"></a>00994   tmp += <a class="code" href="sal__functions_8h.html#a4ac7c8d8d01b567b3a288a79a2b65709">DisplayOpaqueValue</a>(he-&gt;sce_pcookie, he-&gt;sce_cookie_size, tmp);
<a name="l00995"></a>00995   tmp += sprintf(tmp, <span class="stringliteral">&quot; entry {%p fileid=%&quot;</span>PRIu64<span class="stringliteral">&quot;} lock {&quot;</span>,
<a name="l00996"></a>00996                  he-&gt;sce_pentry,
<a name="l00997"></a>00997                  (<a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a>)he-&gt;sce_pentry-&gt;attributes.fileid);
<a name="l00998"></a>00998   <span class="keywordflow">if</span>(he-&gt;sce_lock_entry != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l00999"></a>00999     {
<a name="l01000"></a>01000       tmp += sprintf(tmp, <span class="stringliteral">&quot;%p owner {&quot;</span>, he-&gt;sce_lock_entry);
<a name="l01001"></a>01001 
<a name="l01002"></a>01002       tmp += <a class="code" href="sal__functions_8h.html#a1abfb205d2e54a2f02769650dfd22da8">DisplayOwner</a>(he-&gt;sce_lock_entry-&gt;sle_owner, tmp);
<a name="l01003"></a>01003 
<a name="l01004"></a>01004       tmp += sprintf(tmp, <span class="stringliteral">&quot;} type=%s start=0x%llx end=0x%llx blocked=%s}&quot;</span>,
<a name="l01005"></a>01005                      <a class="code" href="state__lock_8c.html#ab14c3d284d8c8926d94d1affda7becfe">str_lockt</a>(he-&gt;sce_lock_entry-&gt;sle_lock.lock_type),
<a name="l01006"></a>01006                      (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) he-&gt;sce_lock_entry-&gt;sle_lock.lock_start,
<a name="l01007"></a>01007                      (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(&amp;he-&gt;sce_lock_entry-&gt;sle_lock),
<a name="l01008"></a>01008                      <a class="code" href="state__lock_8c.html#a1d2e069f4bfd755214775ef4b7a7eb6f">str_blocked</a>(he-&gt;sce_lock_entry-&gt;sle_blocked));
<a name="l01009"></a>01009     }
<a name="l01010"></a>01010   <span class="keywordflow">else</span>
<a name="l01011"></a>01011     {
<a name="l01012"></a>01012       tmp += sprintf(tmp, <span class="stringliteral">&quot;&lt;NULL&gt;}&quot;</span>);
<a name="l01013"></a>01013     }
<a name="l01014"></a>01014 
<a name="l01015"></a>01015   <span class="keywordflow">return</span> tmp - str;
<a name="l01016"></a>01016 }
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 <span class="keywordtype">int</span> <a class="code" href="sal__functions_8h.html#a95b660b8fdd2bca936cb887ea11cae0c">display_lock_cookie_val</a>(<a class="code" href="structhash__buff.html">hash_buffer_t</a> * pbuff, <span class="keywordtype">char</span> *str)
<a name="l01019"></a>01019 {
<a name="l01020"></a>01020   <span class="keywordflow">return</span> display_lock_cookie_entry((state_cookie_entry_t *)pbuff-&gt;<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a>, str);
<a name="l01021"></a>01021 }
<a name="l01022"></a>01022 
<a name="l01023"></a>01023 <span class="keywordtype">int</span> <a class="code" href="sal__functions_8h.html#afcffaa0282205d9adda3dc3b08146d96">compare_lock_cookie_key</a>(<a class="code" href="structhash__buff.html">hash_buffer_t</a> * buff1, <a class="code" href="structhash__buff.html">hash_buffer_t</a> * buff2)
<a name="l01024"></a>01024 {
<a name="l01025"></a>01025   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>) &amp;&amp; <a class="code" href="log_8h.html#ac778c7aeca566b747dd5bb1baecb6316">isDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a7e2c1f02849dd5d1ed43e3ec7443bb93">COMPONENT_HASHTABLE</a>))
<a name="l01026"></a>01026     {
<a name="l01027"></a>01027       <span class="keywordtype">char</span> str1[HASHTABLE_DISPLAY_STRLEN];
<a name="l01028"></a>01028       <span class="keywordtype">char</span> str2[HASHTABLE_DISPLAY_STRLEN];
<a name="l01029"></a>01029 
<a name="l01030"></a>01030       <a class="code" href="sal__functions_8h.html#af55a980d426ac2729a2ec5e558302d84">display_lock_cookie_key</a>(buff1, str1);
<a name="l01031"></a>01031       <a class="code" href="sal__functions_8h.html#af55a980d426ac2729a2ec5e558302d84">display_lock_cookie_key</a>(buff2, str2);
<a name="l01032"></a>01032       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01033"></a>01033                    <span class="stringliteral">&quot;{%s} vs {%s}&quot;</span>, str1, str2);
<a name="l01034"></a>01034     }
<a name="l01035"></a>01035 
<a name="l01036"></a>01036   <span class="keywordflow">if</span>(buff1-&gt;<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a> == buff2-&gt;<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a>)
<a name="l01037"></a>01037     <span class="keywordflow">return</span> 0;
<a name="l01038"></a>01038 
<a name="l01039"></a>01039   <span class="keywordflow">if</span>(buff1-&gt;<a class="code" href="structhash__buff.html#aae02d0ce42b7fda47c6f9a3138fce7b3">len</a> != buff2-&gt;<a class="code" href="structhash__buff.html#aae02d0ce42b7fda47c6f9a3138fce7b3">len</a>)
<a name="l01040"></a>01040     <span class="keywordflow">return</span> 1;
<a name="l01041"></a>01041 
<a name="l01042"></a>01042   <span class="keywordflow">if</span>(buff1-&gt;<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a> == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> || buff2-&gt;<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a> == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01043"></a>01043     <span class="keywordflow">return</span> 1;
<a name="l01044"></a>01044 
<a name="l01045"></a>01045   <span class="keywordflow">return</span> memcmp(buff1-&gt;<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a>, buff2-&gt;<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a>, buff1-&gt;<a class="code" href="structhash__buff.html#aae02d0ce42b7fda47c6f9a3138fce7b3">len</a>);
<a name="l01046"></a>01046 }
<a name="l01047"></a>01047 
<a name="l01048"></a>01048 <a class="code" href="extended__types_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> <a class="code" href="sal__functions_8h.html#aa6a0c164e1747ed1b9f0fda8abf95b14">lock_cookie_value_hash_func</a>(<a class="code" href="structhash__param.html">hash_parameter_t</a> * p_hparam,
<a name="l01049"></a>01049                                      <a class="code" href="structhash__buff.html">hash_buffer_t</a> * buffclef)
<a name="l01050"></a>01050 {
<a name="l01051"></a>01051   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sum = 0;
<a name="l01052"></a>01052   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l01053"></a>01053   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="nsm_8h.html#ab0bd7560790c13b656fd58e17e35143e">res</a>;
<a name="l01054"></a>01054   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="nfs__rpc__dispatcher__thread_8c.html#ae19b5cb1e7688def1ee7b7668378cfbc">pdata</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) buffclef-&gt;<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a>;
<a name="l01055"></a>01055 
<a name="l01056"></a>01056   <span class="comment">/* Compute the sum of all the characters */</span>
<a name="l01057"></a>01057   <span class="keywordflow">for</span>(i = 0; i &lt; buffclef-&gt;len; i++)
<a name="l01058"></a>01058     sum +=(<span class="keywordtype">unsigned</span> char) pdata[i];
<a name="l01059"></a>01059 
<a name="l01060"></a>01060   res = (<span class="keywordtype">unsigned</span> long) sum +
<a name="l01061"></a>01061         (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) buffclef-&gt;<a class="code" href="structhash__buff.html#aae02d0ce42b7fda47c6f9a3138fce7b3">len</a>;
<a name="l01062"></a>01062 
<a name="l01063"></a>01063   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ac778c7aeca566b747dd5bb1baecb6316">isDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a7e2c1f02849dd5d1ed43e3ec7443bb93">COMPONENT_HASHTABLE</a>))
<a name="l01064"></a>01064     <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01065"></a>01065                  <span class="stringliteral">&quot;value = %lu&quot;</span>, res % p_hparam-&gt;<a class="code" href="structhash__param.html#ac835083bd319700097c852ab29852d69">index_size</a>);
<a name="l01066"></a>01066 
<a name="l01067"></a>01067   <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(res % p_hparam-&gt;<a class="code" href="structhash__param.html#ac835083bd319700097c852ab29852d69">index_size</a>);
<a name="l01068"></a>01068 }
<a name="l01069"></a>01069 
<a name="l01070"></a>01070 <a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a> <a class="code" href="sal__functions_8h.html#a2efa0877e5656aa6a7feb36641e445f0">lock_cookie_rbt_hash_func</a>(<a class="code" href="structhash__param.html">hash_parameter_t</a> * p_hparam,
<a name="l01071"></a>01071                                    <a class="code" href="structhash__buff.html">hash_buffer_t</a> * buffclef)
<a name="l01072"></a>01072 {
<a name="l01073"></a>01073   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sum = 0;
<a name="l01074"></a>01074   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l01075"></a>01075   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="nsm_8h.html#ab0bd7560790c13b656fd58e17e35143e">res</a>;
<a name="l01076"></a>01076   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pdata = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) buffclef-&gt;<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a>;
<a name="l01077"></a>01077 
<a name="l01078"></a>01078   <span class="comment">/* Compute the sum of all the characters */</span>
<a name="l01079"></a>01079   <span class="keywordflow">for</span>(i = 0; i &lt; buffclef-&gt;len; i++)
<a name="l01080"></a>01080     sum +=(<span class="keywordtype">unsigned</span> char) pdata[i];
<a name="l01081"></a>01081 
<a name="l01082"></a>01082   res = (<span class="keywordtype">unsigned</span> long) sum +
<a name="l01083"></a>01083         (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) buffclef-&gt;<a class="code" href="structhash__buff.html#aae02d0ce42b7fda47c6f9a3138fce7b3">len</a>;
<a name="l01084"></a>01084 
<a name="l01085"></a>01085   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ac778c7aeca566b747dd5bb1baecb6316">isDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a7e2c1f02849dd5d1ed43e3ec7443bb93">COMPONENT_HASHTABLE</a>))
<a name="l01086"></a>01086     <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <span class="stringliteral">&quot;rbt = %lu&quot;</span>, res);
<a name="l01087"></a>01087 
<a name="l01088"></a>01088   <span class="keywordflow">return</span> <a class="code" href="nsm_8h.html#ab0bd7560790c13b656fd58e17e35143e">res</a>;
<a name="l01089"></a>01089 }
<a name="l01090"></a>01090 
<a name="l01091"></a>01091 <span class="keywordtype">void</span> free_cookie(state_cookie_entry_t * p_cookie_entry,
<a name="l01092"></a>01092                  bool_t                 unblock)
<a name="l01093"></a>01093 {
<a name="l01094"></a>01094   <span class="keywordtype">char</span>   str[HASHTABLE_DISPLAY_STRLEN];
<a name="l01095"></a>01095   <span class="keywordtype">void</span> * pcookie = p_cookie_entry-&gt;sce_pcookie;
<a name="l01096"></a>01096 
<a name="l01097"></a>01097   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>))
<a name="l01098"></a>01098     display_lock_cookie_entry(p_cookie_entry, str);
<a name="l01099"></a>01099 
<a name="l01100"></a>01100   <span class="comment">/* Since the cookie is not in the hash table, we can just free the memory */</span>
<a name="l01101"></a>01101   <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01102"></a>01102                <span class="stringliteral">&quot;Free Lock Cookie {%s}&quot;</span>,
<a name="l01103"></a>01103                str);
<a name="l01104"></a>01104 
<a name="l01105"></a>01105   <span class="comment">/* If block data is still attached to lock entry, remove it */</span>
<a name="l01106"></a>01106   <span class="keywordflow">if</span>(p_cookie_entry-&gt;sce_lock_entry != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> &amp;&amp; unblock)
<a name="l01107"></a>01107     {
<a name="l01108"></a>01108       <span class="keywordflow">if</span>(p_cookie_entry-&gt;sce_lock_entry-&gt;sle_block_data != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01109"></a>01109         p_cookie_entry-&gt;sce_lock_entry-&gt;sle_block_data-&gt;sbd_blocked_cookie = <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01110"></a>01110 
<a name="l01111"></a>01111       <a class="code" href="state__lock_8c.html#aafed8460a8729acbd1e617f95606550e">lock_entry_dec_ref</a>(p_cookie_entry-&gt;sce_lock_entry);
<a name="l01112"></a>01112     }
<a name="l01113"></a>01113 
<a name="l01114"></a>01114   <span class="comment">/* Free the memory for the cookie and the cookie entry */</span>
<a name="l01115"></a>01115   memset(pcookie, 0, p_cookie_entry-&gt;sce_cookie_size);
<a name="l01116"></a>01116   memset(p_cookie_entry, 0, <span class="keyword">sizeof</span>(*p_cookie_entry));
<a name="l01117"></a>01117 
<a name="l01118"></a>01118   gsh_free(pcookie);
<a name="l01119"></a>01119   gsh_free(p_cookie_entry);
<a name="l01120"></a>01120 }
<a name="l01121"></a>01121 
<a name="l01122"></a>01122 <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> state_add_grant_cookie(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>         * pentry,
<a name="l01123"></a>01123                                       <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>     * pcontext,
<a name="l01124"></a>01124                                       <span class="keywordtype">void</span>                  * pcookie,
<a name="l01125"></a>01125                                       <span class="keywordtype">int</span>                     cookie_size,
<a name="l01126"></a>01126                                       <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>    * lock_entry,
<a name="l01127"></a>01127                                       state_cookie_entry_t ** ppcookie_entry,
<a name="l01128"></a>01128                                       <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>        * pstatus)
<a name="l01129"></a>01129 {
<a name="l01130"></a>01130   <a class="code" href="structhash__buff.html">hash_buffer_t</a>          buffkey, buffval;
<a name="l01131"></a>01131   state_cookie_entry_t * hash_entry;
<a name="l01132"></a>01132   <span class="keywordtype">char</span>                   str[HASHTABLE_DISPLAY_STRLEN];
<a name="l01133"></a>01133 
<a name="l01134"></a>01134   *ppcookie_entry = <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01135"></a>01135 
<a name="l01136"></a>01136   <span class="keywordflow">if</span>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a> == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> || pcookie == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> || cookie_size == 0)
<a name="l01137"></a>01137     {
<a name="l01138"></a>01138       <span class="comment">/* Something&#39;s wrong with this entry */</span>
<a name="l01139"></a>01139       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5bad9f0a73bb6dfcc7334423be5606e0719">STATE_INCONSISTENT_ENTRY</a>;
<a name="l01140"></a>01140       <span class="keywordflow">return</span> *pstatus;
<a name="l01141"></a>01141     }
<a name="l01142"></a>01142 
<a name="l01143"></a>01143   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>))
<a name="l01144"></a>01144     <a class="code" href="sal__functions_8h.html#a4ac7c8d8d01b567b3a288a79a2b65709">DisplayOpaqueValue</a>(pcookie, cookie_size, str);
<a name="l01145"></a>01145 
<a name="l01146"></a>01146   hash_entry = gsh_malloc(<span class="keyword">sizeof</span>(*hash_entry));
<a name="l01147"></a>01147   <span class="keywordflow">if</span>(hash_entry == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01148"></a>01148     {
<a name="l01149"></a>01149       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01150"></a>01150                    <span class="stringliteral">&quot;KEY {%s} NO MEMORY&quot;</span>,
<a name="l01151"></a>01151                    str);
<a name="l01152"></a>01152       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba83de6e519398c6a0377256b70f1d58fc">STATE_MALLOC_ERROR</a>;
<a name="l01153"></a>01153       <span class="keywordflow">return</span> *pstatus;
<a name="l01154"></a>01154     }
<a name="l01155"></a>01155 
<a name="l01156"></a>01156   memset(hash_entry, 0, <span class="keyword">sizeof</span>(*hash_entry));
<a name="l01157"></a>01157 
<a name="l01158"></a>01158   buffkey.<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a> = gsh_malloc(cookie_size);
<a name="l01159"></a>01159   <span class="keywordflow">if</span>(buffkey.<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a> == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01160"></a>01160     {
<a name="l01161"></a>01161       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01162"></a>01162                    <span class="stringliteral">&quot;KEY {%s} NO MEMORY&quot;</span>,
<a name="l01163"></a>01163                    str);
<a name="l01164"></a>01164       gsh_free(hash_entry);
<a name="l01165"></a>01165       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba83de6e519398c6a0377256b70f1d58fc">STATE_MALLOC_ERROR</a>;
<a name="l01166"></a>01166       <span class="keywordflow">return</span> *pstatus;
<a name="l01167"></a>01167     }
<a name="l01168"></a>01168 
<a name="l01169"></a>01169   hash_entry-&gt;sce_pentry      = pentry;
<a name="l01170"></a>01170   hash_entry-&gt;sce_lock_entry  = lock_entry;
<a name="l01171"></a>01171   hash_entry-&gt;sce_pcookie     = buffkey.<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a>;
<a name="l01172"></a>01172   hash_entry-&gt;sce_cookie_size = cookie_size;
<a name="l01173"></a>01173 
<a name="l01174"></a>01174   memcpy(buffkey.<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a>, pcookie, cookie_size);
<a name="l01175"></a>01175   buffkey.<a class="code" href="structhash__buff.html#aae02d0ce42b7fda47c6f9a3138fce7b3">len</a>   = cookie_size;
<a name="l01176"></a>01176   buffval.<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a> = (<span class="keywordtype">void</span> *)hash_entry;
<a name="l01177"></a>01177   buffval.<a class="code" href="structhash__buff.html#aae02d0ce42b7fda47c6f9a3138fce7b3">len</a>   = <span class="keyword">sizeof</span>(*hash_entry);
<a name="l01178"></a>01178 
<a name="l01179"></a>01179   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>))
<a name="l01180"></a>01180     display_lock_cookie_entry(hash_entry, str);
<a name="l01181"></a>01181 
<a name="l01182"></a>01182 
<a name="l01183"></a>01183   <span class="keywordflow">if</span>(<a class="code" href="group__HTExported.html#ga613e404f11079c49c4020b659fe681cd" title="Set a pair (key,value) into the Hash Table.">HashTable_Test_And_Set</a>
<a name="l01184"></a>01184      (ht_lock_cookies, &amp;buffkey, &amp;buffval,
<a name="l01185"></a>01185       <a class="code" href="group__HTStructs.html#ggab434086e69de04e0dcb4a269625c83e3a160497855cb35a4e7db24152027751cd">HASHTABLE_SET_HOW_SET_NO_OVERWRITE</a>) != <a class="code" href="HashTable_8h.html#a0d8b1857db622f6fc6484505310913d1ae64a2488a63ad86c9c51faa790508940">HASHTABLE_SUCCESS</a>)
<a name="l01186"></a>01186     {
<a name="l01187"></a>01187       gsh_free(hash_entry);
<a name="l01188"></a>01188       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01189"></a>01189                    <span class="stringliteral">&quot;Lock Cookie {%s} HASH TABLE ERROR&quot;</span>,
<a name="l01190"></a>01190                    str);
<a name="l01191"></a>01191       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba34633edc62d73aff0d7afd0c6c456a7c">STATE_HASH_TABLE_ERROR</a>;
<a name="l01192"></a>01192       <span class="keywordflow">return</span> *pstatus;
<a name="l01193"></a>01193     }
<a name="l01194"></a>01194 
<a name="l01195"></a>01195   <span class="comment">/* Increment lock entry reference count and link it to the cookie */</span>
<a name="l01196"></a>01196   <a class="code" href="state__lock_8c.html#a0385907ca0d4bed7af36c0feb8c52c33">lock_entry_inc_ref</a>(lock_entry);
<a name="l01197"></a>01197   lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>-&gt;sbd_blocked_cookie = hash_entry;
<a name="l01198"></a>01198 
<a name="l01199"></a>01199   <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01200"></a>01200                <span class="stringliteral">&quot;Lock Cookie {%s} Added&quot;</span>,
<a name="l01201"></a>01201                str);
<a name="l01202"></a>01202 
<a name="l01203"></a>01203   <span class="keywordflow">switch</span>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>-&gt;sbd_grant_type)
<a name="l01204"></a>01204     {
<a name="l01205"></a>01205       <span class="keywordflow">case</span> STATE_GRANT_NONE:
<a name="l01206"></a>01206         <span class="comment">/* Shouldn&#39;t get here */</span>
<a name="l01207"></a>01207         *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5bad9f0a73bb6dfcc7334423be5606e0719">STATE_INCONSISTENT_ENTRY</a>;
<a name="l01208"></a>01208         <span class="keywordflow">break</span>;
<a name="l01209"></a>01209 
<a name="l01210"></a>01210       <span class="keywordflow">case</span> STATE_GRANT_FSAL_AVAILABLE:
<a name="l01211"></a>01211         <span class="comment">/* Now that we are sure we can continue, try to acquire the FSAL lock */</span>
<a name="l01212"></a>01212         <span class="comment">/* If we get STATE_LOCK_BLOCKED we need to return... */</span>
<a name="l01213"></a>01213         *pstatus = <a class="code" href="state__lock_8c.html#a1b7532d0b0321fdd328c9057087b1cfb">do_lock_op</a>(pentry,
<a name="l01214"></a>01214                               pcontext,
<a name="l01215"></a>01215                               lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>,
<a name="l01216"></a>01216                               <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a441819d7daf06f76149039b2f862fe09">FSAL_OP_LOCKB</a>,
<a name="l01217"></a>01217                               lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>,
<a name="l01218"></a>01218                               &amp;lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>,
<a name="l01219"></a>01219                               <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l01220"></a>01220                               <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l01221"></a>01221                               <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l01222"></a>01222         <span class="keywordflow">break</span>;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224       <span class="keywordflow">case</span> STATE_GRANT_INTERNAL:
<a name="l01225"></a>01225         <span class="comment">/* Now that we are sure we can continue, acquire the FSAL lock */</span>
<a name="l01226"></a>01226         <span class="comment">/* If we get STATE_LOCK_BLOCKED we need to return... */</span>
<a name="l01227"></a>01227         *pstatus = <a class="code" href="state__lock_8c.html#a1b7532d0b0321fdd328c9057087b1cfb">do_lock_op</a>(pentry,
<a name="l01228"></a>01228                               pcontext,
<a name="l01229"></a>01229                               lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>,
<a name="l01230"></a>01230                               <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a6b55656aca96aac5afa516294b42607c">FSAL_OP_LOCK</a>,
<a name="l01231"></a>01231                               lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>,
<a name="l01232"></a>01232                               &amp;lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>,
<a name="l01233"></a>01233                               <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l01234"></a>01234                               <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l01235"></a>01235                               <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l01236"></a>01236         <span class="keywordflow">break</span>;
<a name="l01237"></a>01237 
<a name="l01238"></a>01238       <span class="keywordflow">case</span> STATE_GRANT_FSAL:
<a name="l01239"></a>01239         <span class="comment">/* No need to go to FSAL for lock */</span>
<a name="l01240"></a>01240         *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l01241"></a>01241         <span class="keywordflow">break</span>;
<a name="l01242"></a>01242     }
<a name="l01243"></a>01243 
<a name="l01244"></a>01244   <span class="keywordflow">if</span>(*pstatus != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l01245"></a>01245     {
<a name="l01246"></a>01246       <span class="comment">/* lock will be returned to right blocking type if it is still blocking</span>
<a name="l01247"></a>01247 <span class="comment">       * we could lose a block if we failed for any other reason</span>
<a name="l01248"></a>01248 <span class="comment">       */</span>
<a name="l01249"></a>01249       <span class="keywordflow">if</span>(*pstatus == <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5badd826dce2e924f2a4b52b320e2271546">STATE_LOCK_BLOCKED</a>)
<a name="l01250"></a>01250         <a class="code" href="log_8h.html#aa7aee8ec65b5baafb430f8d2a7588d53">LogDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01251"></a>01251                  <span class="stringliteral">&quot;Unable to lock FSAL for %s lock, error=%s&quot;</span>,
<a name="l01252"></a>01252                  <a class="code" href="state__lock_8c.html#a1d2e069f4bfd755214775ef4b7a7eb6f">str_blocked</a>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a>),
<a name="l01253"></a>01253                  <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(*pstatus));
<a name="l01254"></a>01254       <span class="keywordflow">else</span>
<a name="l01255"></a>01255         <a class="code" href="log_8h.html#a3cf3c22fac6bb9871e25007551caeb13">LogMajor</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01256"></a>01256                  <span class="stringliteral">&quot;Unable to lock FSAL for %s lock, error=%s&quot;</span>,
<a name="l01257"></a>01257                  <a class="code" href="state__lock_8c.html#a1d2e069f4bfd755214775ef4b7a7eb6f">str_blocked</a>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a>),
<a name="l01258"></a>01258                  <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(*pstatus));
<a name="l01259"></a>01259 
<a name="l01260"></a>01260       LogEntry(<span class="stringliteral">&quot;Entry&quot;</span>, lock_entry);
<a name="l01261"></a>01261 
<a name="l01262"></a>01262       <span class="comment">/* And release the cookie without unblocking the lock.</span>
<a name="l01263"></a>01263 <span class="comment">       * grant_blocked_locks() will decide whether to keep or free the block.</span>
<a name="l01264"></a>01264 <span class="comment">       */</span>
<a name="l01265"></a>01265       free_cookie(hash_entry, <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l01266"></a>01266 
<a name="l01267"></a>01267       <span class="keywordflow">return</span> *pstatus;
<a name="l01268"></a>01268     }
<a name="l01269"></a>01269 
<a name="l01270"></a>01270   *ppcookie_entry = hash_entry;
<a name="l01271"></a>01271   <span class="keywordflow">return</span> *pstatus;
<a name="l01272"></a>01272 }
<a name="l01273"></a>01273 
<a name="l01274"></a>01274 <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> state_cancel_grant(<a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l01275"></a>01275                                   state_cookie_entry_t * cookie_entry,
<a name="l01276"></a>01276                                   <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>       * pstatus)
<a name="l01277"></a>01277 {
<a name="l01278"></a>01278   <span class="comment">/* We had acquired an FSAL lock, need to release it. */</span>
<a name="l01279"></a>01279   *pstatus = <a class="code" href="state__lock_8c.html#a1b7532d0b0321fdd328c9057087b1cfb">do_lock_op</a>(cookie_entry-&gt;sce_pentry,
<a name="l01280"></a>01280                         pcontext,
<a name="l01281"></a>01281                         cookie_entry-&gt;sce_lock_entry-&gt;sle_pexport,
<a name="l01282"></a>01282                         <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a8f700b40f6f195020b62a7f289d771b9">FSAL_OP_UNLOCK</a>,
<a name="l01283"></a>01283                         cookie_entry-&gt;sce_lock_entry-&gt;sle_owner,
<a name="l01284"></a>01284                         &amp;cookie_entry-&gt;sce_lock_entry-&gt;sle_lock,
<a name="l01285"></a>01285                         <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,   <span class="comment">/* no conflict expected */</span>
<a name="l01286"></a>01286                         <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l01287"></a>01287                         <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l01288"></a>01288 
<a name="l01289"></a>01289   <span class="keywordflow">if</span>(*pstatus != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l01290"></a>01290     <a class="code" href="log_8h.html#a3cf3c22fac6bb9871e25007551caeb13">LogMajor</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01291"></a>01291              <span class="stringliteral">&quot;Unable to unlock FSAL for canceled GRANTED lock, error=%s&quot;</span>,
<a name="l01292"></a>01292              <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(*pstatus));
<a name="l01293"></a>01293 
<a name="l01294"></a>01294   <span class="comment">/* And release the cookie and unblock lock (because lock will be removed) */</span>
<a name="l01295"></a>01295   free_cookie(cookie_entry, <a class="code" href="HashTable_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);
<a name="l01296"></a>01296 
<a name="l01297"></a>01297   <span class="keywordflow">return</span> *pstatus;
<a name="l01298"></a>01298 }
<a name="l01299"></a>01299 
<a name="l01300"></a>01300 <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> state_find_grant(<span class="keywordtype">void</span>                  * pcookie,
<a name="l01301"></a>01301                                 <span class="keywordtype">int</span>                     cookie_size,
<a name="l01302"></a>01302                                 state_cookie_entry_t ** ppcookie_entry,
<a name="l01303"></a>01303                                 <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>        * pstatus)
<a name="l01304"></a>01304 {
<a name="l01305"></a>01305   <a class="code" href="structhash__buff.html">hash_buffer_t</a> buffkey;
<a name="l01306"></a>01306   <a class="code" href="structhash__buff.html">hash_buffer_t</a> buffval;
<a name="l01307"></a>01307   <a class="code" href="structhash__buff.html">hash_buffer_t</a> buffused_key;
<a name="l01308"></a>01308   <span class="keywordtype">char</span>          str[HASHTABLE_DISPLAY_STRLEN];
<a name="l01309"></a>01309 
<a name="l01310"></a>01310   buffkey.<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a> = (caddr_t) pcookie;
<a name="l01311"></a>01311   buffkey.<a class="code" href="structhash__buff.html#aae02d0ce42b7fda47c6f9a3138fce7b3">len</a>   = cookie_size;
<a name="l01312"></a>01312 
<a name="l01313"></a>01313   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>) &amp;&amp; <a class="code" href="log_8h.html#ac778c7aeca566b747dd5bb1baecb6316">isDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a7e2c1f02849dd5d1ed43e3ec7443bb93">COMPONENT_HASHTABLE</a>))
<a name="l01314"></a>01314     {
<a name="l01315"></a>01315       <a class="code" href="sal__functions_8h.html#af55a980d426ac2729a2ec5e558302d84">display_lock_cookie_key</a>(&amp;buffkey, str);
<a name="l01316"></a>01316       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01317"></a>01317                    <span class="stringliteral">&quot;KEY {%s}&quot;</span>, str);
<a name="l01318"></a>01318     }
<a name="l01319"></a>01319 
<a name="l01320"></a>01320   <span class="keywordflow">if</span>(<a class="code" href="group__HTExported.html#ga3caa5586e0aae5d4dc1b86c19984c2ae" title="Look up, return, and remove an entry.">HashTable_Get_and_Del</a>(ht_lock_cookies, &amp;buffkey, &amp;buffval, &amp;buffused_key) != <a class="code" href="HashTable_8h.html#a0d8b1857db622f6fc6484505310913d1ae64a2488a63ad86c9c51faa790508940">HASHTABLE_SUCCESS</a>)
<a name="l01321"></a>01321     {
<a name="l01322"></a>01322       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01323"></a>01323                    <span class="stringliteral">&quot;KEY {%s} NOTFOUND&quot;</span>, str);
<a name="l01324"></a>01324       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba986b4650b7a1f03aa4262c2ae3c5c9f0">STATE_BAD_COOKIE</a>;
<a name="l01325"></a>01325       <span class="keywordflow">return</span> *pstatus;
<a name="l01326"></a>01326     }
<a name="l01327"></a>01327 
<a name="l01328"></a>01328   *ppcookie_entry = (state_cookie_entry_t *) buffval.<a class="code" href="structhash__buff.html#a3c326798104545de8aea28c86307299d">pdata</a>;
<a name="l01329"></a>01329 
<a name="l01330"></a>01330   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>) &amp;&amp; <a class="code" href="log_8h.html#ac778c7aeca566b747dd5bb1baecb6316">isDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a7e2c1f02849dd5d1ed43e3ec7443bb93">COMPONENT_HASHTABLE</a>))
<a name="l01331"></a>01331     {
<a name="l01332"></a>01332       <span class="keywordtype">char</span> str[HASHTABLE_DISPLAY_STRLEN];
<a name="l01333"></a>01333 
<a name="l01334"></a>01334       display_lock_cookie_entry(*ppcookie_entry, str);
<a name="l01335"></a>01335       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01336"></a>01336                    <span class="stringliteral">&quot;Found Lock Cookie {%s}&quot;</span>, str);
<a name="l01337"></a>01337     }
<a name="l01338"></a>01338 
<a name="l01339"></a>01339   *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l01340"></a>01340   <span class="keywordflow">return</span> *pstatus;
<a name="l01341"></a>01341 }
<a name="l01342"></a>01342 
<a name="l01343"></a>01343 <span class="keywordtype">void</span> grant_blocked_lock_immediate(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>         * pentry,
<a name="l01344"></a>01344                                   <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>     * pcontext,
<a name="l01345"></a>01345                                   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>    * lock_entry)
<a name="l01346"></a>01346 {
<a name="l01347"></a>01347   state_cookie_entry_t * pcookie = <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01348"></a>01348   <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>         state_status;
<a name="l01349"></a>01349 
<a name="l01350"></a>01350   <span class="comment">/* Try to clean up blocked lock. */</span>
<a name="l01351"></a>01351   <span class="keywordflow">if</span>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a> != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01352"></a>01352     {
<a name="l01353"></a>01353       <span class="keywordflow">if</span>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>-&gt;sbd_blocked_cookie != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01354"></a>01354         {
<a name="l01355"></a>01355           <span class="comment">/* Cookie is attached, try to get it */</span>
<a name="l01356"></a>01356           pcookie = lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>-&gt;sbd_blocked_cookie;
<a name="l01357"></a>01357 
<a name="l01358"></a>01358           <span class="keywordflow">if</span>(state_find_grant(pcookie-&gt;sce_pcookie,
<a name="l01359"></a>01359                               pcookie-&gt;sce_cookie_size,
<a name="l01360"></a>01360                               &amp;pcookie,
<a name="l01361"></a>01361                               &amp;state_status) == <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l01362"></a>01362             {
<a name="l01363"></a>01363               <span class="comment">/* We&#39;ve got the cookie, free the cookie and the blocked lock */</span>
<a name="l01364"></a>01364               free_cookie(pcookie, <a class="code" href="HashTable_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);
<a name="l01365"></a>01365             }
<a name="l01366"></a>01366           <span class="keywordflow">else</span>
<a name="l01367"></a>01367             {
<a name="l01368"></a>01368               <span class="comment">/* Otherwise, another thread has the cookie, let it do it&#39;s business. */</span>
<a name="l01369"></a>01369               <span class="keywordflow">return</span>;
<a name="l01370"></a>01370             }
<a name="l01371"></a>01371         }
<a name="l01372"></a>01372       <span class="keywordflow">else</span>
<a name="l01373"></a>01373         {
<a name="l01374"></a>01374           <span class="comment">/* We have block data but no cookie, so we can just free the block data */</span>
<a name="l01375"></a>01375           memset(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>, 0, <span class="keyword">sizeof</span>(*lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>));
<a name="l01376"></a>01376           gsh_free(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>);
<a name="l01377"></a>01377           lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a> = <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01378"></a>01378         }
<a name="l01379"></a>01379     }
<a name="l01380"></a>01380 
<a name="l01381"></a>01381   <span class="comment">/* Mark lock as granted */</span>
<a name="l01382"></a>01382   lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> = <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8facf0a49c1e4b5d2ab379c0b9c61df625d">STATE_NON_BLOCKING</a>;
<a name="l01383"></a>01383 
<a name="l01384"></a>01384   <span class="comment">/* Merge any touching or overlapping locks into this one. */</span>
<a name="l01385"></a>01385   LogEntry(<span class="stringliteral">&quot;Granted immediate, merging locks for&quot;</span>, lock_entry);
<a name="l01386"></a>01386 
<a name="l01387"></a>01387   merge_lock_entry(pentry, pcontext, lock_entry);
<a name="l01388"></a>01388   LogEntry(<span class="stringliteral">&quot;Immediate Granted entry&quot;</span>, lock_entry);
<a name="l01389"></a>01389 
<a name="l01390"></a>01390   <span class="comment">/* A lock downgrade could unblock blocked locks */</span>
<a name="l01391"></a>01391   grant_blocked_locks(pentry, pcontext);
<a name="l01392"></a>01392 }
<a name="l01393"></a>01393 
<a name="l01394"></a>01394 <span class="keywordtype">void</span> state_complete_grant(<a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>     * pcontext,
<a name="l01395"></a>01395                           state_cookie_entry_t  * cookie_entry)
<a name="l01396"></a>01396 {
<a name="l01397"></a>01397   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>   * lock_entry;
<a name="l01398"></a>01398   <a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry;
<a name="l01399"></a>01399 
<a name="l01400"></a>01400   lock_entry = cookie_entry-&gt;sce_lock_entry;
<a name="l01401"></a>01401   pentry     = cookie_entry-&gt;sce_pentry;
<a name="l01402"></a>01402 
<a name="l01403"></a>01403   <span class="comment">/* This routine does not call cache_inode_inc_pin_ref() because there MUST be</span>
<a name="l01404"></a>01404 <span class="comment">   * at least one lock present for there to be a cookie_entry to even allow this</span>
<a name="l01405"></a>01405 <span class="comment">   * routine to be called, and therefor the cache entry MUST be pinned.</span>
<a name="l01406"></a>01406 <span class="comment">   */</span>
<a name="l01407"></a>01407 
<a name="l01408"></a>01408   pthread_rwlock_wrlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l01409"></a>01409 
<a name="l01410"></a>01410   <span class="comment">/* We need to make sure lock is ready to be granted */</span>
<a name="l01411"></a>01411   <span class="keywordflow">if</span>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> == <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa90ad1f35643849c6891a9fda17568fd9">STATE_GRANTING</a>)
<a name="l01412"></a>01412     {
<a name="l01413"></a>01413       <span class="comment">/* Mark lock as granted */</span>
<a name="l01414"></a>01414       lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> = <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8facf0a49c1e4b5d2ab379c0b9c61df625d">STATE_NON_BLOCKING</a>;
<a name="l01415"></a>01415 
<a name="l01416"></a>01416       <span class="comment">/* Merge any touching or overlapping locks into this one. */</span>
<a name="l01417"></a>01417       LogEntry(<span class="stringliteral">&quot;Granted, merging locks for&quot;</span>, lock_entry);
<a name="l01418"></a>01418       merge_lock_entry(pentry, pcontext, lock_entry);
<a name="l01419"></a>01419 
<a name="l01420"></a>01420       LogEntry(<span class="stringliteral">&quot;Granted entry&quot;</span>, lock_entry);
<a name="l01421"></a>01421 
<a name="l01422"></a>01422       <span class="comment">/* A lock downgrade could unblock blocked locks */</span>
<a name="l01423"></a>01423       grant_blocked_locks(pentry, pcontext);
<a name="l01424"></a>01424     }
<a name="l01425"></a>01425 
<a name="l01426"></a>01426   <span class="comment">/* Free cookie and unblock lock.</span>
<a name="l01427"></a>01427 <span class="comment">   * If somehow the lock was unlocked/canceled while the GRANT</span>
<a name="l01428"></a>01428 <span class="comment">   * was in progress, this will completely clean up the lock.</span>
<a name="l01429"></a>01429 <span class="comment">   */</span>
<a name="l01430"></a>01430   free_cookie(cookie_entry, <a class="code" href="HashTable_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);
<a name="l01431"></a>01431 
<a name="l01432"></a>01432   <span class="comment">/* In case all locks have wound up free, we must release the pin reference. */</span>
<a name="l01433"></a>01433   <span class="keywordflow">if</span>(glist_empty(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list))
<a name="l01434"></a>01434       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l01435"></a>01435 
<a name="l01436"></a>01436   pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l01437"></a>01437 }
<a name="l01438"></a>01438 
<a name="l01439"></a>01439 <span class="keywordtype">void</span> try_to_grant_lock(<a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>   * lock_entry)
<a name="l01440"></a>01440 {
<a name="l01441"></a>01441   <a class="code" href="sal__data_8h.html#a1001ffe2f7419b6964636d7a7de0acab">granted_callback_t</a>     call_back;
<a name="l01442"></a>01442   <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8f">state_blocking_t</a>       blocked;
<a name="l01443"></a>01443   <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>         status;
<a name="l01444"></a>01444 
<a name="l01445"></a>01445   <span class="comment">/* Try to grant if not cancelled and has block data */</span>
<a name="l01446"></a>01446   <span class="keywordflow">if</span>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> != <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fac759db4905b8050e53794a5664963f52">STATE_CANCELED</a> &amp;&amp;
<a name="l01447"></a>01447      lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a> != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01448"></a>01448     {
<a name="l01449"></a>01449       call_back = lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>-&gt;sbd_granted_callback;
<a name="l01450"></a>01450       <span class="comment">/*</span>
<a name="l01451"></a>01451 <span class="comment">       * Mark the lock_entry as provisionally granted and make the granted</span>
<a name="l01452"></a>01452 <span class="comment">       * call back. The granted call back is responsible for acquiring a</span>
<a name="l01453"></a>01453 <span class="comment">       * reference to the lock entry if needed.</span>
<a name="l01454"></a>01454 <span class="comment">       */</span>
<a name="l01455"></a>01455       blocked = lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a>;
<a name="l01456"></a>01456       lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> = <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa90ad1f35643849c6891a9fda17568fd9">STATE_GRANTING</a>;
<a name="l01457"></a>01457       <span class="keywordflow">if</span>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>-&gt;sbd_grant_type == STATE_GRANT_NONE)
<a name="l01458"></a>01458         lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>-&gt;sbd_grant_type = STATE_GRANT_INTERNAL;
<a name="l01459"></a>01459 
<a name="l01460"></a>01460       <span class="keywordflow">if</span>(call_back(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#aab01a34cef6e6bbeea32a83e906b7f32">sle_pentry</a>,
<a name="l01461"></a>01461                    lock_entry,
<a name="l01462"></a>01462                    &amp;status) == <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5badd826dce2e924f2a4b52b320e2271546">STATE_LOCK_BLOCKED</a>)
<a name="l01463"></a>01463         {
<a name="l01464"></a>01464           <span class="comment">/* The lock is still blocked, restore it&#39;s type and leave it in the list */</span>
<a name="l01465"></a>01465           lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> = blocked;
<a name="l01466"></a>01466           <span class="keywordflow">return</span>;
<a name="l01467"></a>01467         }
<a name="l01468"></a>01468 
<a name="l01469"></a>01469       <span class="keywordflow">if</span>(status == <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l01470"></a>01470         <span class="keywordflow">return</span>;
<a name="l01471"></a>01471     }
<a name="l01472"></a>01472 
<a name="l01473"></a>01473   <span class="comment">/* There was no call back data, the call back failed, or the block was cancelled.</span>
<a name="l01474"></a>01474 <span class="comment">   * Remove lock from list.</span>
<a name="l01475"></a>01475 <span class="comment">   */</span>
<a name="l01476"></a>01476   LogEntry(<span class="stringliteral">&quot;Removing blocked entry&quot;</span>, lock_entry);
<a name="l01477"></a>01477   remove_from_locklist(lock_entry);
<a name="l01478"></a>01478 }
<a name="l01479"></a>01479 
<a name="l01480"></a>01480 <span class="keywordtype">void</span> process_blocked_lock_upcall(<a class="code" href="sal__data_8h.html#a3035370b7b027cc7c897284b50c5fc12">state_block_data_t</a>   * block_data)
<a name="l01481"></a>01481 {
<a name="l01482"></a>01482   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> * lock_entry = block_data-&gt;sbd_lock_entry;
<a name="l01483"></a>01483   <a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>      * pentry = lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#aab01a34cef6e6bbeea32a83e906b7f32">sle_pentry</a>;
<a name="l01484"></a>01484 
<a name="l01485"></a>01485   <span class="comment">/* This routine does not call cache_inode_inc_pin_ref() because there MUST be</span>
<a name="l01486"></a>01486 <span class="comment">   * at least one lock present for there to be a block_data to even allow this</span>
<a name="l01487"></a>01487 <span class="comment">   * routine to be called, and therefor the cache entry MUST be pinned.</span>
<a name="l01488"></a>01488 <span class="comment">   */</span>
<a name="l01489"></a>01489 
<a name="l01490"></a>01490   pthread_rwlock_wrlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l01491"></a>01491 
<a name="l01492"></a>01492   try_to_grant_lock(lock_entry);
<a name="l01493"></a>01493 
<a name="l01494"></a>01494   <span class="comment">/* In case all locks have wound up free, we must release the pin reference. */</span>
<a name="l01495"></a>01495   <span class="keywordflow">if</span>(glist_empty(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list))
<a name="l01496"></a>01496       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l01497"></a>01497 
<a name="l01498"></a>01498   pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l01499"></a>01499 }
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 <span class="keyword">static</span> <span class="keywordtype">void</span> grant_blocked_locks(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l01502"></a>01502                                 <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext)
<a name="l01503"></a>01503 {
<a name="l01504"></a>01504   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>   * found_entry;
<a name="l01505"></a>01505   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a>    * glist, * glistn;
<a name="l01506"></a>01506   <a class="code" href="structfsal__staticfsinfo__t.html">fsal_staticfsinfo_t</a>  * pstatic = pcontext-&gt;<a class="code" href="structfsal__op__context____.html#ac482a39c83ca2b5a26e42cb61cb3e312">export_context</a>-&gt;<a class="code" href="structfsal__export__context____.html#a70839eaa0e8abf7bb73887260a349f24">fe_static_fs_info</a>;
<a name="l01507"></a>01507 
<a name="l01508"></a>01508   <span class="comment">/* If FSAL supports async blocking locks, allow it to grant blocked locks. */</span>
<a name="l01509"></a>01509   <span class="keywordflow">if</span>(pstatic-&gt;<a class="code" href="structfsal__staticfsinfo__t.html#a2d6d73987342316ef0a250af1941a6b5">lock_support_async_block</a>)
<a name="l01510"></a>01510     <span class="keywordflow">return</span>;
<a name="l01511"></a>01511 
<a name="l01512"></a>01512   <a class="code" href="nlm__list_8h.html#aa69d13cb8dd7170f99c92dddccde8ebe">glist_for_each_safe</a>(glist, glistn, &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list)
<a name="l01513"></a>01513     {
<a name="l01514"></a>01514       found_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l01515"></a>01515 
<a name="l01516"></a>01516       <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> != <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa1f8b0da78f5ae271f0ff4c1ed4faf586">STATE_NLM_BLOCKING</a> &amp;&amp;
<a name="l01517"></a>01517          found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> != <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fafdc4ecdcd48b788e6b4ceb21e112dbb4">STATE_NFSV4_BLOCKING</a>)
<a name="l01518"></a>01518           <span class="keywordflow">continue</span>;
<a name="l01519"></a>01519 
<a name="l01520"></a>01520       <span class="comment">/* Found a blocked entry for this file, see if we can place the lock. */</span>
<a name="l01521"></a>01521       <span class="keywordflow">if</span>(get_overlapping_entry(pentry,
<a name="l01522"></a>01522                                pcontext,
<a name="l01523"></a>01523                                found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>,
<a name="l01524"></a>01524                                &amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>) != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01525"></a>01525         <span class="keywordflow">continue</span>;
<a name="l01526"></a>01526 
<a name="l01527"></a>01527       <span class="comment">/* Found an entry that might work, try to grant it. */</span>
<a name="l01528"></a>01528       try_to_grant_lock(found_entry);
<a name="l01529"></a>01529     }
<a name="l01530"></a>01530 }
<a name="l01531"></a>01531 
<a name="l01532"></a>01532 <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> cancel_blocked_lock(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l01533"></a>01533                                    <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l01534"></a>01534                                    <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>   * lock_entry)
<a name="l01535"></a>01535 {
<a name="l01536"></a>01536   state_cookie_entry_t * pcookie = <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01537"></a>01537   <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>         state_status;
<a name="l01538"></a>01538 
<a name="l01539"></a>01539   <span class="comment">/* Mark lock as canceled */</span>
<a name="l01540"></a>01540   LogEntry(<span class="stringliteral">&quot;Cancelling blocked&quot;</span>, lock_entry);
<a name="l01541"></a>01541   lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> = <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fac759db4905b8050e53794a5664963f52">STATE_CANCELED</a>;
<a name="l01542"></a>01542 
<a name="l01543"></a>01543       <span class="comment">/* Unlocking the entire region will remove any FSAL locks we held, whether</span>
<a name="l01544"></a>01544 <span class="comment">       * from fully granted locks, or from blocking locks that were in the process</span>
<a name="l01545"></a>01545 <span class="comment">       * of being granted.</span>
<a name="l01546"></a>01546 <span class="comment">       */</span>
<a name="l01547"></a>01547 
<a name="l01548"></a>01548   <span class="comment">/* Try to clean up blocked lock if a cookie is present */</span>
<a name="l01549"></a>01549   <span class="keywordflow">if</span>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a> != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> &amp;&amp;
<a name="l01550"></a>01550      lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>-&gt;sbd_blocked_cookie != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01551"></a>01551     {
<a name="l01552"></a>01552       <span class="comment">/* Cookie is attached, try to get it */</span>
<a name="l01553"></a>01553       pcookie = lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a>-&gt;sbd_blocked_cookie;
<a name="l01554"></a>01554 
<a name="l01555"></a>01555       <span class="keywordflow">if</span>(state_find_grant(pcookie-&gt;sce_pcookie,
<a name="l01556"></a>01556                           pcookie-&gt;sce_cookie_size,
<a name="l01557"></a>01557                           &amp;pcookie,
<a name="l01558"></a>01558                           &amp;state_status) == <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l01559"></a>01559         {
<a name="l01560"></a>01560           <span class="comment">/* We&#39;ve got the cookie, free the cookie and the blocked lock */</span>
<a name="l01561"></a>01561           free_cookie(pcookie, <a class="code" href="HashTable_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);
<a name="l01562"></a>01562         }
<a name="l01563"></a>01563       <span class="comment">/* otherwise, another thread has the cookie, let it do it&#39;s business,</span>
<a name="l01564"></a>01564 <span class="comment">       * which won&#39;t be much, since we&#39;ve already marked the lock CANCELED.</span>
<a name="l01565"></a>01565 <span class="comment">       */</span>
<a name="l01566"></a>01566     }
<a name="l01567"></a>01567   <span class="keywordflow">else</span>
<a name="l01568"></a>01568     {
<a name="l01569"></a>01569       <span class="comment">/* Otherwise, if block data is present, it will be freed when the lock</span>
<a name="l01570"></a>01570 <span class="comment">       * entry is freed. If the cookie is held, the refcount it holds will</span>
<a name="l01571"></a>01571 <span class="comment">       * prevent the lock entry from being released until the cookie is</span>
<a name="l01572"></a>01572 <span class="comment">       * freed.</span>
<a name="l01573"></a>01573 <span class="comment">       */</span>
<a name="l01574"></a>01574 
<a name="l01575"></a>01575       <span class="comment">/* Since a cookie was not found, the lock must still be in a state</span>
<a name="l01576"></a>01576 <span class="comment">       * of needing cancelling.</span>
<a name="l01577"></a>01577 <span class="comment">       */</span>
<a name="l01578"></a>01578       state_status = <a class="code" href="state__lock_8c.html#a1b7532d0b0321fdd328c9057087b1cfb">do_lock_op</a>(pentry,
<a name="l01579"></a>01579                                 pcontext,
<a name="l01580"></a>01580                                 lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>,
<a name="l01581"></a>01581                                 <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a553b9eb10247c0b6f8713df07e39ce70">FSAL_OP_CANCEL</a>,
<a name="l01582"></a>01582                                 lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>,
<a name="l01583"></a>01583                                 &amp;lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>,
<a name="l01584"></a>01584                                 <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,   <span class="comment">/* no conflict expected */</span>
<a name="l01585"></a>01585                                 <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l01586"></a>01586                                 <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>); <span class="comment">/* overlap not relevant */</span>
<a name="l01587"></a>01587 
<a name="l01588"></a>01588       <span class="keywordflow">if</span>(state_status != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l01589"></a>01589         {
<a name="l01590"></a>01590           <span class="comment">/* Unable to cancel, assume that granted upcall is on it&#39;s way. */</span>
<a name="l01591"></a>01591           LogEntry(<span class="stringliteral">&quot;Unable to cancel (grant upcall expected)&quot;</span>, lock_entry);
<a name="l01592"></a>01592           <span class="keywordflow">return</span> <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l01593"></a>01593         }
<a name="l01594"></a>01594     }
<a name="l01595"></a>01595 
<a name="l01596"></a>01596   <span class="comment">/* Remove the lock from the lock list*/</span>
<a name="l01597"></a>01597   LogEntry(<span class="stringliteral">&quot;Removing&quot;</span>, lock_entry);
<a name="l01598"></a>01598   remove_from_locklist(lock_entry);
<a name="l01599"></a>01599 
<a name="l01600"></a>01600   <span class="keywordflow">return</span> state_status;
<a name="l01601"></a>01601 }
<a name="l01602"></a>01602 
<a name="l01623"></a>01623 <span class="keywordtype">void</span> cancel_blocked_locks_range(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l01624"></a>01624                                 <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l01625"></a>01625                                 <a class="code" href="structstate__owner__t.html">state_owner_t</a>        * powner,
<a name="l01626"></a>01626                                 <a class="code" href="structstate__t.html">state_t</a>              * pstate,
<a name="l01627"></a>01627                                 <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * plock)
<a name="l01628"></a>01628 {
<a name="l01629"></a>01629   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a>  * glist, * glistn;
<a name="l01630"></a>01630   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> * found_entry = <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01631"></a>01631   <a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a>             found_entry_end, plock_end = <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(plock);
<a name="l01632"></a>01632 
<a name="l01633"></a>01633   <a class="code" href="nlm__list_8h.html#aa69d13cb8dd7170f99c92dddccde8ebe">glist_for_each_safe</a>(glist, glistn, &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list)
<a name="l01634"></a>01634     {
<a name="l01635"></a>01635       found_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l01636"></a>01636 
<a name="l01637"></a>01637       <span class="comment">/* Skip locks not owned by owner */</span>
<a name="l01638"></a>01638       <span class="keywordflow">if</span>(powner != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> &amp;&amp; <a class="code" href="sal__functions_8h.html#aafafe1a716e741dd5d3a2b3f579ddb94">different_owners</a>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>, powner))
<a name="l01639"></a>01639         <span class="keywordflow">continue</span>;
<a name="l01640"></a>01640 
<a name="l01641"></a>01641       <span class="comment">/* Skip locks owned by this NLM state.</span>
<a name="l01642"></a>01642 <span class="comment">       * This protects NLM locks from the current iteration of an NLM</span>
<a name="l01643"></a>01643 <span class="comment">       * client from being released by SM_NOTIFY.</span>
<a name="l01644"></a>01644 <span class="comment">       */</span>
<a name="l01645"></a>01645       <span class="keywordflow">if</span>(pstate != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a> &amp;&amp;
<a name="l01646"></a>01646          <a class="code" href="state__lock_8c.html#ae3f90b2b0f41f7eff5fef21dde258371">lock_owner_is_nlm</a>(found_entry) &amp;&amp;
<a name="l01647"></a>01647          found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abb0ab635935d64b79bb2a6d3ee328731">sle_state</a> == pstate)
<a name="l01648"></a>01648         <span class="keywordflow">continue</span>;
<a name="l01649"></a>01649 
<a name="l01650"></a>01650       <span class="comment">/* Skip granted locks */</span>
<a name="l01651"></a>01651       <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> == <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8facf0a49c1e4b5d2ab379c0b9c61df625d">STATE_NON_BLOCKING</a>)
<a name="l01652"></a>01652         <span class="keywordflow">continue</span>;
<a name="l01653"></a>01653 
<a name="l01654"></a>01654       LogEntry(<span class="stringliteral">&quot;Checking&quot;</span>, found_entry);
<a name="l01655"></a>01655 
<a name="l01656"></a>01656       found_entry_end = <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(&amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>);
<a name="l01657"></a>01657 
<a name="l01658"></a>01658       <span class="keywordflow">if</span>((found_entry_end &gt;= plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>) &amp;&amp;
<a name="l01659"></a>01659          (found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> &lt;= plock_end))
<a name="l01660"></a>01660         {
<a name="l01661"></a>01661           <span class="comment">/* lock overlaps, cancel it. */</span>
<a name="l01662"></a>01662           (void) cancel_blocked_lock(pentry, pcontext, found_entry);
<a name="l01663"></a>01663         }
<a name="l01664"></a>01664     }
<a name="l01665"></a>01665 }
<a name="l01666"></a>01666 
<a name="l01667"></a>01667 <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> state_release_grant(<a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>     * pcontext,
<a name="l01668"></a>01668                                    state_cookie_entry_t  * cookie_entry,
<a name="l01669"></a>01669                                    <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>        * pstatus)
<a name="l01670"></a>01670 {
<a name="l01671"></a>01671   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>   * lock_entry;
<a name="l01672"></a>01672   <a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry;
<a name="l01673"></a>01673 
<a name="l01674"></a>01674   *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l01675"></a>01675 
<a name="l01676"></a>01676   lock_entry = cookie_entry-&gt;sce_lock_entry;
<a name="l01677"></a>01677   pentry     = cookie_entry-&gt;sce_pentry;
<a name="l01678"></a>01678 
<a name="l01679"></a>01679   <span class="comment">/* This routine does not call cache_inode_inc_pin_ref() because there MUST be</span>
<a name="l01680"></a>01680 <span class="comment">   * at least one lock present for there to be a cookie_entry to even allow this</span>
<a name="l01681"></a>01681 <span class="comment">   * routine to be called, and therefor the cache entry MUST be pinned.</span>
<a name="l01682"></a>01682 <span class="comment">   */</span>
<a name="l01683"></a>01683 
<a name="l01684"></a>01684   pthread_rwlock_wrlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l01685"></a>01685 
<a name="l01686"></a>01686   <span class="comment">/* We need to make sure lock is only &quot;granted&quot; once...</span>
<a name="l01687"></a>01687 <span class="comment">   * It&#39;s (remotely) possible that due to latency, we might end up processing</span>
<a name="l01688"></a>01688 <span class="comment">   * two GRANTED_RSP calls at the same time.</span>
<a name="l01689"></a>01689 <span class="comment">   */</span>
<a name="l01690"></a>01690   <span class="keywordflow">if</span>(lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> == <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa90ad1f35643849c6891a9fda17568fd9">STATE_GRANTING</a>)
<a name="l01691"></a>01691     {
<a name="l01692"></a>01692       <span class="comment">/* Mark lock as canceled */</span>
<a name="l01693"></a>01693       lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> = <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fac759db4905b8050e53794a5664963f52">STATE_CANCELED</a>;
<a name="l01694"></a>01694 
<a name="l01695"></a>01695       <span class="comment">/* Remove the lock from the lock list.</span>
<a name="l01696"></a>01696 <span class="comment">       * Will not free yet because of cookie reference to lock entry.</span>
<a name="l01697"></a>01697 <span class="comment">       */</span>
<a name="l01698"></a>01698       LogEntry(<span class="stringliteral">&quot;Release Grant Removing&quot;</span>, lock_entry);
<a name="l01699"></a>01699       remove_from_locklist(lock_entry);
<a name="l01700"></a>01700 
<a name="l01701"></a>01701       <span class="comment">/* We had acquired an FSAL lock, need to release it. */</span>
<a name="l01702"></a>01702       *pstatus = <a class="code" href="state__lock_8c.html#a1b7532d0b0321fdd328c9057087b1cfb">do_lock_op</a>(pentry,
<a name="l01703"></a>01703                             pcontext,
<a name="l01704"></a>01704                             lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>,
<a name="l01705"></a>01705                             <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a8f700b40f6f195020b62a7f289d771b9">FSAL_OP_UNLOCK</a>,
<a name="l01706"></a>01706                             lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>,
<a name="l01707"></a>01707                             &amp;lock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>,
<a name="l01708"></a>01708                             <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,   <span class="comment">/* no conflict expected */</span>
<a name="l01709"></a>01709                             <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l01710"></a>01710                             <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l01711"></a>01711 
<a name="l01712"></a>01712       <span class="keywordflow">if</span>(*pstatus != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l01713"></a>01713         <a class="code" href="log_8h.html#a3cf3c22fac6bb9871e25007551caeb13">LogMajor</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01714"></a>01714                  <span class="stringliteral">&quot;Unable to unlock FSAL for released GRANTED lock, error=%s&quot;</span>,
<a name="l01715"></a>01715                  <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(*pstatus));
<a name="l01716"></a>01716     }
<a name="l01717"></a>01717 
<a name="l01718"></a>01718   <span class="comment">/* Free the cookie and unblock the lock.</span>
<a name="l01719"></a>01719 <span class="comment">   * This will release our final reference on the lock entry and should free it.</span>
<a name="l01720"></a>01720 <span class="comment">   * (Unless another thread has a reference for some reason.</span>
<a name="l01721"></a>01721 <span class="comment">   */</span>
<a name="l01722"></a>01722   free_cookie(cookie_entry, <a class="code" href="HashTable_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);
<a name="l01723"></a>01723 
<a name="l01724"></a>01724   <span class="comment">/* Check to see if we can grant any blocked locks. */</span>
<a name="l01725"></a>01725   grant_blocked_locks(pentry, pcontext);
<a name="l01726"></a>01726 
<a name="l01727"></a>01727   <span class="comment">/* In case all locks have wound up free, we must release the pin reference. */</span>
<a name="l01728"></a>01728   <span class="keywordflow">if</span>(glist_empty(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list))
<a name="l01729"></a>01729       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l01730"></a>01730 
<a name="l01731"></a>01731   pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l01732"></a>01732 
<a name="l01733"></a>01733   <span class="keywordflow">return</span> *pstatus;
<a name="l01734"></a>01734 }
<a name="l01735"></a>01735 <span class="preprocessor">#endif</span>
<a name="l01736"></a>01736 <span class="preprocessor"></span>
<a name="l01737"></a>01737 <span class="comment">/******************************************************************************</span>
<a name="l01738"></a>01738 <span class="comment"> *</span>
<a name="l01739"></a>01739 <span class="comment"> * Functions to interract with FSAL</span>
<a name="l01740"></a>01740 <span class="comment"> *</span>
<a name="l01741"></a>01741 <span class="comment"> ******************************************************************************/</span>
<a name="l01742"></a><a class="code" href="state__lock_8c.html#a14af780a8b8d7d194b6341cb990abe55">01742</a> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="state__lock_8c.html#a14af780a8b8d7d194b6341cb990abe55">fsal_lock_op_str</a>(<a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20">fsal_lock_op_t</a> op)
<a name="l01743"></a>01743 {
<a name="l01744"></a>01744   <span class="keywordflow">switch</span>(op)
<a name="l01745"></a>01745     {
<a name="l01746"></a>01746       <span class="keywordflow">case</span> <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a96f4504000c44593c6c3fc816b8b17be">FSAL_OP_LOCKT</a>:  <span class="keywordflow">return</span> <span class="stringliteral">&quot;FSAL_OP_LOCKT &quot;</span>;
<a name="l01747"></a>01747       <span class="keywordflow">case</span> <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a6b55656aca96aac5afa516294b42607c">FSAL_OP_LOCK</a>:   <span class="keywordflow">return</span> <span class="stringliteral">&quot;FSAL_OP_LOCK  &quot;</span>;
<a name="l01748"></a>01748       <span class="keywordflow">case</span> <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a441819d7daf06f76149039b2f862fe09">FSAL_OP_LOCKB</a>:  <span class="keywordflow">return</span> <span class="stringliteral">&quot;FSAL_OP_LOCKB &quot;</span>;
<a name="l01749"></a>01749       <span class="keywordflow">case</span> <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a8f700b40f6f195020b62a7f289d771b9">FSAL_OP_UNLOCK</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;FSAL_OP_UNLOCK&quot;</span>;
<a name="l01750"></a>01750       <span class="keywordflow">case</span> <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a553b9eb10247c0b6f8713df07e39ce70">FSAL_OP_CANCEL</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;FSAL_OP_CANCEL&quot;</span>;
<a name="l01751"></a>01751     }
<a name="l01752"></a>01752   <span class="keywordflow">return</span> <span class="stringliteral">&quot;unknown&quot;</span>;
<a name="l01753"></a>01753 }
<a name="l01754"></a>01754 
<a name="l01774"></a><a class="code" href="state__lock_8c.html#ad32f4450e856d2b954549c116a8b9c89">01774</a> <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> <a class="code" href="state__lock_8c.html#ad32f4450e856d2b954549c116a8b9c89">do_unlock_no_owner</a>(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l01775"></a>01775                                   <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l01776"></a>01776                                   <a class="code" href="structexportlist____.html">exportlist_t</a>         * pexport,
<a name="l01777"></a>01777                                   <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * plock)
<a name="l01778"></a>01778 {
<a name="l01779"></a>01779   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> * unlock_entry;
<a name="l01780"></a>01780   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a>    fsal_unlock_list;
<a name="l01781"></a>01781   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a>  * glist, *glistn;
<a name="l01782"></a>01782   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> * found_entry;
<a name="l01783"></a>01783   <a class="code" href="structfsal__status____.html">fsal_status_t</a>        fsal_status;
<a name="l01784"></a>01784   <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>       status = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>, t_status;
<a name="l01785"></a>01785   <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>  * punlock;
<a name="l01786"></a>01786 
<a name="l01787"></a>01787   unlock_entry = create_state_lock_entry(pentry,
<a name="l01788"></a>01788                                          pcontext,
<a name="l01789"></a>01789                                          pexport,
<a name="l01790"></a>01790                                          <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8facf0a49c1e4b5d2ab379c0b9c61df625d">STATE_NON_BLOCKING</a>,
<a name="l01791"></a>01791                                          &amp;unknown_owner, <span class="comment">/* no real owner */</span>
<a name="l01792"></a>01792                                          <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <span class="comment">/* no real state */</span>
<a name="l01793"></a>01793                                          plock);
<a name="l01794"></a>01794 
<a name="l01795"></a>01795   <span class="keywordflow">if</span>(unlock_entry == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01796"></a>01796     <span class="keywordflow">return</span> <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba83de6e519398c6a0377256b70f1d58fc">STATE_MALLOC_ERROR</a>;
<a name="l01797"></a>01797 
<a name="l01798"></a>01798   init_glist(&amp;fsal_unlock_list);
<a name="l01799"></a>01799 
<a name="l01800"></a>01800   glist_add_tail(&amp;fsal_unlock_list, &amp;unlock_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#ae87ceb436fd9f2ee0fbc19f454d74d52">sle_list</a>);
<a name="l01801"></a>01801 
<a name="l01802"></a>01802   LogEntry(<span class="stringliteral">&quot;Generating FSAL Unlock List&quot;</span>, unlock_entry);
<a name="l01803"></a>01803 
<a name="l01804"></a>01804   <span class="keywordflow">if</span>(subtract_list_from_list(pentry,
<a name="l01805"></a>01805                              pcontext,
<a name="l01806"></a>01806                              &amp;fsal_unlock_list,
<a name="l01807"></a>01807                              &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list,
<a name="l01808"></a>01808                              &amp;status) != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l01809"></a>01809     {
<a name="l01810"></a>01810       <span class="comment">/* We ran out of memory while trying to build the unlock list.</span>
<a name="l01811"></a>01811 <span class="comment">       * We have already released the locks from cache inode lock list.</span>
<a name="l01812"></a>01812 <span class="comment">       */</span>
<a name="l01813"></a>01813       <span class="comment">// TODO FSF: what do we do now?</span>
<a name="l01814"></a>01814       <a class="code" href="log_8h.html#a3cf3c22fac6bb9871e25007551caeb13">LogMajor</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01815"></a>01815                <span class="stringliteral">&quot;Error %s while trying to create unlock list&quot;</span>,
<a name="l01816"></a>01816                <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(status));
<a name="l01817"></a>01817     }
<a name="l01818"></a>01818 
<a name="l01819"></a>01819   <a class="code" href="nlm__list_8h.html#aa69d13cb8dd7170f99c92dddccde8ebe">glist_for_each_safe</a>(glist, glistn, &amp;fsal_unlock_list)
<a name="l01820"></a>01820     {
<a name="l01821"></a>01821       found_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l01822"></a>01822       punlock     = &amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>;
<a name="l01823"></a>01823 
<a name="l01824"></a>01824       LogEntry(<span class="stringliteral">&quot;FSAL Unlock&quot;</span>, found_entry);
<a name="l01825"></a>01825 
<a name="l01826"></a>01826       fsal_status = <a class="code" href="fsal__glue_8c.html#a42374ed01c314aefae9353c78073912a">FSAL_lock_op</a>(<a class="code" href="cache__inode__open__close_8c.html#ad56db1a0f05a02b28859ef3256cdd3ba" title="Returns a file descriptor, if open.">cache_inode_fd</a>(pentry),
<a name="l01827"></a>01827                                  &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#aaa7abf75d0997dba12395a01c09be705">handle</a>,
<a name="l01828"></a>01828                                  pcontext,
<a name="l01829"></a>01829                                  <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l01830"></a>01830                                  <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a8f700b40f6f195020b62a7f289d771b9">FSAL_OP_UNLOCK</a>,
<a name="l01831"></a>01831                                  *punlock,
<a name="l01832"></a>01832                                  <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l01833"></a>01833 
<a name="l01834"></a>01834       t_status = <a class="code" href="sal__functions_8h.html#ae1399e643e66d68aadc280927fa3895d">state_error_convert</a>(fsal_status);
<a name="l01835"></a>01835 
<a name="l01836"></a>01836       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01837"></a>01837                    <span class="stringliteral">&quot;FSAL_lock_op returned %s&quot;</span>,
<a name="l01838"></a>01838                    <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(t_status));
<a name="l01839"></a>01839 
<a name="l01840"></a>01840       <span class="keywordflow">if</span>(t_status != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l01841"></a>01841         {
<a name="l01842"></a>01842           <span class="comment">// TODO FSF: what do we do now?</span>
<a name="l01843"></a>01843           <a class="code" href="log_8h.html#a3cf3c22fac6bb9871e25007551caeb13">LogMajor</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01844"></a>01844                    <span class="stringliteral">&quot;Error %s while trying to do FSAL Unlock&quot;</span>,
<a name="l01845"></a>01845                    <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(status));
<a name="l01846"></a>01846           status = t_status;
<a name="l01847"></a>01847         }
<a name="l01848"></a>01848 
<a name="l01849"></a>01849       remove_from_locklist(found_entry);
<a name="l01850"></a>01850     }
<a name="l01851"></a>01851 
<a name="l01852"></a>01852   <span class="keywordflow">return</span> status;
<a name="l01853"></a>01853 }
<a name="l01854"></a>01854 
<a name="l01855"></a><a class="code" href="state__lock_8c.html#a1b7532d0b0321fdd328c9057087b1cfb">01855</a> <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> <a class="code" href="state__lock_8c.html#a1b7532d0b0321fdd328c9057087b1cfb">do_lock_op</a>(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l01856"></a>01856                           <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l01857"></a>01857                           <a class="code" href="structexportlist____.html">exportlist_t</a>         * pexport,
<a name="l01858"></a>01858                           <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20">fsal_lock_op_t</a>         lock_op,
<a name="l01859"></a>01859                           <a class="code" href="structstate__owner__t.html">state_owner_t</a>        * powner,
<a name="l01860"></a>01860                           <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * plock,
<a name="l01861"></a>01861                           <a class="code" href="structstate__owner__t.html">state_owner_t</a>       ** holder,   <span class="comment">/* owner that holds conflicting lock */</span>
<a name="l01862"></a>01862                           <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * conflict, <span class="comment">/* description of conflicting lock */</span>
<a name="l01863"></a>01863                           bool_t                 overlap)  <span class="comment">/* hint that lock overlaps */</span>
<a name="l01864"></a>01864 {
<a name="l01865"></a>01865   <a class="code" href="structfsal__status____.html">fsal_status_t</a>         fsal_status;
<a name="l01866"></a>01866   <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>        status = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l01867"></a>01867   <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>     conflicting_lock;
<a name="l01868"></a>01868   <a class="code" href="structfsal__staticfsinfo__t.html">fsal_staticfsinfo_t</a> * pstatic = pcontext-&gt;<a class="code" href="structfsal__op__context____.html#ac482a39c83ca2b5a26e42cb61cb3e312">export_context</a>-&gt;<a class="code" href="structfsal__export__context____.html#a70839eaa0e8abf7bb73887260a349f24">fe_static_fs_info</a>;
<a name="l01869"></a>01869 
<a name="l01870"></a>01870   <span class="comment">/* Quick exit if:</span>
<a name="l01871"></a>01871 <span class="comment">   * Locks are not supported by FSAL</span>
<a name="l01872"></a>01872 <span class="comment">   * Async blocking locks are not supported and this is a cancel</span>
<a name="l01873"></a>01873 <span class="comment">   * Async blocking locks are not supported and this lock overlaps</span>
<a name="l01874"></a>01874 <span class="comment">   * Lock owners are not supported and hint tells us that lock fully overlaps a</span>
<a name="l01875"></a>01875 <span class="comment">   *   lock we already have (no need to make another FSAL call in that case)</span>
<a name="l01876"></a>01876 <span class="comment">   */</span>
<a name="l01877"></a>01877   <span class="keywordflow">if</span>(!pstatic-&gt;<a class="code" href="structfsal__staticfsinfo__t.html#a879dbeaf698eb458f35d220c7884d8a4">lock_support</a> ||
<a name="l01878"></a>01878      (!pstatic-&gt;<a class="code" href="structfsal__staticfsinfo__t.html#a2d6d73987342316ef0a250af1941a6b5">lock_support_async_block</a> &amp;&amp; lock_op == <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a553b9eb10247c0b6f8713df07e39ce70">FSAL_OP_CANCEL</a>) ||
<a name="l01879"></a>01879      (!pstatic-&gt;<a class="code" href="structfsal__staticfsinfo__t.html#a2d6d73987342316ef0a250af1941a6b5">lock_support_async_block</a> &amp;&amp; overlap) ||
<a name="l01880"></a>01880      (!pstatic-&gt;<a class="code" href="structfsal__staticfsinfo__t.html#ab4e5a23300e74afe7da8c2e261d9db2b">lock_support_owner</a> &amp;&amp; overlap))
<a name="l01881"></a>01881     <span class="keywordflow">return</span> <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l01882"></a>01882 
<a name="l01883"></a>01883   <a class="code" href="sal__functions_8h.html#ad62a073d73c565a7d2bbc850bc16e617">LogLock</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <a class="code" href="log_8h.html#afc14b587b4225c84f4796397df9489e2a59e3d6a98085b3dc7f143072242d2485">NIV_FULL_DEBUG</a>,
<a name="l01884"></a>01884           <a class="code" href="state__lock_8c.html#a14af780a8b8d7d194b6341cb990abe55">fsal_lock_op_str</a>(lock_op), pentry, pcontext, powner, plock);
<a name="l01885"></a>01885 
<a name="l01886"></a>01886   memset(&amp;conflicting_lock, 0, <span class="keyword">sizeof</span>(conflicting_lock));
<a name="l01887"></a>01887 
<a name="l01888"></a>01888   <span class="keywordflow">if</span>(pstatic-&gt;<a class="code" href="structfsal__staticfsinfo__t.html#ab4e5a23300e74afe7da8c2e261d9db2b">lock_support_owner</a> || lock_op != <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a8f700b40f6f195020b62a7f289d771b9">FSAL_OP_UNLOCK</a>)
<a name="l01889"></a>01889     {
<a name="l01890"></a>01890       <span class="keywordflow">if</span>(lock_op == <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a441819d7daf06f76149039b2f862fe09">FSAL_OP_LOCKB</a> &amp;&amp; !pstatic-&gt;<a class="code" href="structfsal__staticfsinfo__t.html#a2d6d73987342316ef0a250af1941a6b5">lock_support_async_block</a>)
<a name="l01891"></a>01891         lock_op = <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a6b55656aca96aac5afa516294b42607c">FSAL_OP_LOCK</a>;
<a name="l01892"></a>01892 
<a name="l01893"></a>01893       fsal_status = <a class="code" href="fsal__glue_8c.html#a42374ed01c314aefae9353c78073912a">FSAL_lock_op</a>(<a class="code" href="cache__inode__open__close_8c.html#ad56db1a0f05a02b28859ef3256cdd3ba" title="Returns a file descriptor, if open.">cache_inode_fd</a>(pentry),
<a name="l01894"></a>01894                                  &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#aaa7abf75d0997dba12395a01c09be705">handle</a>,
<a name="l01895"></a>01895                                  pcontext,
<a name="l01896"></a>01896                                  pstatic-&gt;<a class="code" href="structfsal__staticfsinfo__t.html#ab4e5a23300e74afe7da8c2e261d9db2b">lock_support_owner</a> ? powner : <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l01897"></a>01897                                  lock_op,
<a name="l01898"></a>01898                                  *plock,
<a name="l01899"></a>01899                                  &amp;conflicting_lock);
<a name="l01900"></a>01900 
<a name="l01901"></a>01901       status = <a class="code" href="sal__functions_8h.html#ae1399e643e66d68aadc280927fa3895d">state_error_convert</a>(fsal_status);
<a name="l01902"></a>01902 
<a name="l01903"></a>01903       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01904"></a>01904                    <span class="stringliteral">&quot;FSAL_lock_op returned %s&quot;</span>,
<a name="l01905"></a>01905                    <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(status));
<a name="l01906"></a>01906 
<a name="l01907"></a>01907       <span class="keywordflow">if</span>(status == <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5badd826dce2e924f2a4b52b320e2271546">STATE_LOCK_BLOCKED</a> &amp;&amp; lock_op != <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a441819d7daf06f76149039b2f862fe09">FSAL_OP_LOCKB</a>)
<a name="l01908"></a>01908         {
<a name="l01909"></a>01909           <span class="comment">/* This is an unexpected return code, make sure caller reports an error */</span>
<a name="l01910"></a>01910           <a class="code" href="log_8h.html#a3cf3c22fac6bb9871e25007551caeb13">LogMajor</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01911"></a>01911                    <span class="stringliteral">&quot;FSAL returned unexpected STATE_LOCK_BLOCKED result&quot;</span>);
<a name="l01912"></a>01912           status = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5bae91cdb73a24db0b2263227d98aa82cc3">STATE_FSAL_ERROR</a>;
<a name="l01913"></a>01913         }
<a name="l01914"></a>01914     }
<a name="l01915"></a>01915   <span class="keywordflow">else</span>
<a name="l01916"></a>01916     {
<a name="l01917"></a>01917       status = <a class="code" href="state__lock_8c.html#ad32f4450e856d2b954549c116a8b9c89">do_unlock_no_owner</a>(pentry, pcontext, pexport, plock);
<a name="l01918"></a>01918     }
<a name="l01919"></a>01919 
<a name="l01920"></a>01920   <span class="keywordflow">if</span>(status == <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5baca81ee684ca3b8423644fc1e8e5031fe">STATE_LOCK_CONFLICT</a>)
<a name="l01921"></a>01921     {
<a name="l01922"></a>01922       <span class="keywordflow">if</span>(holder != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01923"></a>01923         {
<a name="l01924"></a>01924           *holder = &amp;<a class="code" href="sal__data_8h.html#a54b5362efb0708c58ca5c23a0fe4bba5">unknown_owner</a>;
<a name="l01925"></a>01925           <a class="code" href="sal__functions_8h.html#acc3428eef541d69d6e181383a8dc9c9d">inc_state_owner_ref</a>(&amp;unknown_owner);
<a name="l01926"></a>01926         }
<a name="l01927"></a>01927       <span class="keywordflow">if</span>(conflict != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01928"></a>01928         {
<a name="l01929"></a>01929           *conflict = conflicting_lock;
<a name="l01930"></a>01930         }
<a name="l01931"></a>01931     }
<a name="l01932"></a>01932 
<a name="l01933"></a>01933   <span class="keywordflow">return</span> status;
<a name="l01934"></a>01934 }
<a name="l01935"></a>01935 
<a name="l01936"></a><a class="code" href="state__lock_8c.html#a3a32bdf5e3fb16345539e2b0a37941ce">01936</a> <span class="keywordtype">void</span> <a class="code" href="state__lock_8c.html#a3a32bdf5e3fb16345539e2b0a37941ce">copy_conflict</a>(<a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>  * found_entry,
<a name="l01937"></a>01937                    <a class="code" href="structstate__owner__t.html">state_owner_t</a>      ** holder,   <span class="comment">/* owner that holds conflicting lock */</span>
<a name="l01938"></a>01938                    <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>   * conflict) <span class="comment">/* description of conflicting lock */</span>
<a name="l01939"></a>01939 {
<a name="l01940"></a>01940   <span class="keywordflow">if</span>(found_entry == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01941"></a>01941     <span class="keywordflow">return</span>;
<a name="l01942"></a>01942 
<a name="l01943"></a>01943   <span class="keywordflow">if</span>(holder != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01944"></a>01944     {
<a name="l01945"></a>01945       *holder = found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>;
<a name="l01946"></a>01946       <a class="code" href="sal__functions_8h.html#acc3428eef541d69d6e181383a8dc9c9d">inc_state_owner_ref</a>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>);
<a name="l01947"></a>01947     }
<a name="l01948"></a>01948   <span class="keywordflow">if</span>(conflict != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l01949"></a>01949     *conflict = found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>;
<a name="l01950"></a>01950 }
<a name="l01951"></a>01951 
<a name="l01952"></a>01952 <span class="comment">/******************************************************************************</span>
<a name="l01953"></a>01953 <span class="comment"> *</span>
<a name="l01954"></a>01954 <span class="comment"> * Primary lock interface functions</span>
<a name="l01955"></a>01955 <span class="comment"> *</span>
<a name="l01956"></a>01956 <span class="comment"> ******************************************************************************/</span>
<a name="l01957"></a>01957 
<a name="l01967"></a><a class="code" href="state__lock_8c.html#ae21f4db4b75246d2226ee18697d36463">01967</a> <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> <a class="code" href="sal__functions_8h.html#ae21f4db4b75246d2226ee18697d36463">state_test</a>(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l01968"></a>01968                           <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l01969"></a>01969                           <a class="code" href="structexportlist____.html">exportlist_t</a>         * pexport,
<a name="l01970"></a>01970                           <a class="code" href="structstate__owner__t.html">state_owner_t</a>        * powner,
<a name="l01971"></a>01971                           <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * plock,
<a name="l01972"></a>01972                           <a class="code" href="structstate__owner__t.html">state_owner_t</a>       ** holder,   <span class="comment">/* owner that holds conflicting lock */</span>
<a name="l01973"></a>01973                           <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * conflict, <span class="comment">/* description of conflicting lock */</span>
<a name="l01974"></a>01974                           <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>       * pstatus)
<a name="l01975"></a>01975 {
<a name="l01976"></a>01976   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>   * found_entry;
<a name="l01977"></a>01977   <a class="code" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a>   cache_status;
<a name="l01978"></a>01978 
<a name="l01979"></a>01979   <a class="code" href="sal__functions_8h.html#ad62a073d73c565a7d2bbc850bc16e617">LogLock</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <a class="code" href="log_8h.html#afc14b587b4225c84f4796397df9489e2a59e3d6a98085b3dc7f143072242d2485">NIV_FULL_DEBUG</a>,
<a name="l01980"></a>01980           <span class="stringliteral">&quot;TEST&quot;</span>,
<a name="l01981"></a>01981           pentry, pcontext, powner, plock);
<a name="l01982"></a>01982 
<a name="l01983"></a>01983   cache_status = <a class="code" href="cache__inode__lru_8c.html#a96bb243e361cf38c5ae8ac4c50c108f1" title="Function to let the state layer pin an entry.">cache_inode_inc_pin_ref</a>(pentry);
<a name="l01984"></a>01984 
<a name="l01985"></a>01985   <span class="keywordflow">if</span>(cache_status != <a class="code" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2a3fdbbb2367268ae84ac11d7b189643d8">CACHE_INODE_SUCCESS</a>)
<a name="l01986"></a>01986     {
<a name="l01987"></a>01987       *pstatus = <a class="code" href="sal__functions_8h.html#a8edcc5485a600a2f7d798bcdd33fdb09">cache_inode_status_to_state_status</a>(cache_status);
<a name="l01988"></a>01988       <a class="code" href="log_8h.html#aa7aee8ec65b5baafb430f8d2a7588d53">LogDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01989"></a>01989                <span class="stringliteral">&quot;Could not pin file&quot;</span>);
<a name="l01990"></a>01990       <span class="keywordflow">return</span> *pstatus;
<a name="l01991"></a>01991     }
<a name="l01992"></a>01992 
<a name="l01993"></a>01993   <span class="keywordflow">if</span>(<a class="code" href="cache__inode__open__close_8c.html#a396684171093081bc52283a6030e6267" title="Opens a file descriptor.">cache_inode_open</a>(pentry, <a class="code" href="fsal__types_8h.html#a2f41a66ed7ecd8494344eff0f56f3784">FSAL_O_RDWR</a>, pcontext, 0, &amp;cache_status) != <a class="code" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2a3fdbbb2367268ae84ac11d7b189643d8">CACHE_INODE_SUCCESS</a>)
<a name="l01994"></a>01994     {
<a name="l01995"></a>01995       *pstatus = <a class="code" href="sal__functions_8h.html#a8edcc5485a600a2f7d798bcdd33fdb09">cache_inode_status_to_state_status</a>(cache_status);
<a name="l01996"></a>01996       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l01997"></a>01997                    <span class="stringliteral">&quot;Could not open file&quot;</span>);
<a name="l01998"></a>01998 
<a name="l01999"></a>01999       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02000"></a>02000 
<a name="l02001"></a>02001       <span class="keywordflow">return</span> *pstatus;
<a name="l02002"></a>02002     }
<a name="l02003"></a>02003 
<a name="l02004"></a>02004   pthread_rwlock_rdlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02005"></a>02005 
<a name="l02006"></a>02006   found_entry = get_overlapping_entry(pentry, pcontext, powner, plock);
<a name="l02007"></a>02007 
<a name="l02008"></a>02008   <span class="keywordflow">if</span>(found_entry != <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l02009"></a>02009     {
<a name="l02010"></a>02010       <span class="comment">/* found a conflicting lock, return it */</span>
<a name="l02011"></a>02011       LogEntry(<span class="stringliteral">&quot;Found conflict&quot;</span>, found_entry);
<a name="l02012"></a>02012       <a class="code" href="state__lock_8c.html#a3a32bdf5e3fb16345539e2b0a37941ce">copy_conflict</a>(found_entry, holder, conflict);
<a name="l02013"></a>02013       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5baca81ee684ca3b8423644fc1e8e5031fe">STATE_LOCK_CONFLICT</a>;
<a name="l02014"></a>02014     }
<a name="l02015"></a>02015   <span class="keywordflow">else</span>
<a name="l02016"></a>02016     {
<a name="l02017"></a>02017       <span class="comment">/* Prepare to make call to FSAL for this lock */</span>
<a name="l02018"></a>02018       *pstatus = <a class="code" href="state__lock_8c.html#a1b7532d0b0321fdd328c9057087b1cfb">do_lock_op</a>(pentry,
<a name="l02019"></a>02019                             pcontext,
<a name="l02020"></a>02020                             pexport,
<a name="l02021"></a>02021                             <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a96f4504000c44593c6c3fc816b8b17be">FSAL_OP_LOCKT</a>,
<a name="l02022"></a>02022                             powner,
<a name="l02023"></a>02023                             plock,
<a name="l02024"></a>02024                             holder,
<a name="l02025"></a>02025                             conflict,
<a name="l02026"></a>02026                             <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l02027"></a>02027 
<a name="l02028"></a>02028       <span class="keywordflow">if</span>(*pstatus != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a> &amp;&amp;
<a name="l02029"></a>02029          *pstatus != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5baca81ee684ca3b8423644fc1e8e5031fe">STATE_LOCK_CONFLICT</a>)
<a name="l02030"></a>02030         {
<a name="l02031"></a>02031           <a class="code" href="log_8h.html#a3cf3c22fac6bb9871e25007551caeb13">LogMajor</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02032"></a>02032                    <span class="stringliteral">&quot;Got error from FSAL lock operation, error=%s&quot;</span>,
<a name="l02033"></a>02033                    <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(*pstatus));
<a name="l02034"></a>02034         }
<a name="l02035"></a>02035       <span class="keywordflow">if</span>(*pstatus == <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l02036"></a>02036         <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02037"></a>02037                      <span class="stringliteral">&quot;No Conflict&quot;</span>);
<a name="l02038"></a>02038       <span class="keywordflow">else</span>
<a name="l02039"></a>02039         <a class="code" href="sal__functions_8h.html#ad62a073d73c565a7d2bbc850bc16e617">LogLock</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <a class="code" href="log_8h.html#afc14b587b4225c84f4796397df9489e2a59e3d6a98085b3dc7f143072242d2485">NIV_FULL_DEBUG</a>,
<a name="l02040"></a>02040                 <span class="stringliteral">&quot;Conflict from FSAL&quot;</span>,
<a name="l02041"></a>02041                 pentry, pcontext, *holder, conflict);
<a name="l02042"></a>02042     }
<a name="l02043"></a>02043 
<a name="l02044"></a>02044   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>) &amp;&amp; <a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a0a066e3c604933ce4e6ceb2b81e9f46d">COMPONENT_MEMLEAKS</a>))
<a name="l02045"></a>02045     LogList(<span class="stringliteral">&quot;Lock List&quot;</span>, pentry, &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list);
<a name="l02046"></a>02046 
<a name="l02047"></a>02047   pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02048"></a>02048 
<a name="l02049"></a>02049   <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02050"></a>02050 
<a name="l02051"></a>02051   <span class="keywordflow">return</span> *pstatus;
<a name="l02052"></a>02052 }
<a name="l02053"></a>02053 
<a name="l02061"></a><a class="code" href="state__lock_8c.html#ab5142ddc607e0835871a86f00020c1ee">02061</a> <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> <a class="code" href="sal__functions_8h.html#ab5142ddc607e0835871a86f00020c1ee">state_lock</a>(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>         * pentry,
<a name="l02062"></a>02062                           <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>     * pcontext,
<a name="l02063"></a>02063                           <a class="code" href="structexportlist____.html">exportlist_t</a>          * pexport,
<a name="l02064"></a>02064                           <a class="code" href="structstate__owner__t.html">state_owner_t</a>         * powner,
<a name="l02065"></a>02065                           <a class="code" href="structstate__t.html">state_t</a>               * pstate,
<a name="l02066"></a>02066                           <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8f">state_blocking_t</a>        blocking,
<a name="l02067"></a>02067                           <a class="code" href="sal__data_8h.html#a3035370b7b027cc7c897284b50c5fc12">state_block_data_t</a>    * block_data,
<a name="l02068"></a>02068                           <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>     * plock,
<a name="l02069"></a>02069                           <a class="code" href="structstate__owner__t.html">state_owner_t</a>        ** holder,   <span class="comment">/* owner that holds conflicting lock */</span>
<a name="l02070"></a>02070                           <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>     * conflict, <span class="comment">/* description of conflicting lock */</span>
<a name="l02071"></a>02071                           <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>        * pstatus)
<a name="l02072"></a>02072 {
<a name="l02073"></a>02073   bool_t                 allow = <a class="code" href="HashTable_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, overlap = <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l02074"></a>02074   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a>    * glist;
<a name="l02075"></a>02075   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>   * found_entry;
<a name="l02076"></a>02076   <a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a>               found_entry_end;
<a name="l02077"></a>02077   <a class="code" href="extended__types_8h.html#ad27ed092432b64ff558d2254c278720f">uint64_t</a>               plock_end = <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(plock);
<a name="l02078"></a>02078   <a class="code" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a>   cache_status;
<a name="l02079"></a>02079   <a class="code" href="structfsal__staticfsinfo__t.html">fsal_staticfsinfo_t</a>  * pstatic = pcontext-&gt;<a class="code" href="structfsal__op__context____.html#ac482a39c83ca2b5a26e42cb61cb3e312">export_context</a>-&gt;<a class="code" href="structfsal__export__context____.html#a70839eaa0e8abf7bb73887260a349f24">fe_static_fs_info</a>;
<a name="l02080"></a>02080   <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20">fsal_lock_op_t</a>         lock_op;
<a name="l02081"></a>02081 
<a name="l02082"></a>02082   cache_status = <a class="code" href="cache__inode__lru_8c.html#a96bb243e361cf38c5ae8ac4c50c108f1" title="Function to let the state layer pin an entry.">cache_inode_inc_pin_ref</a>(pentry);
<a name="l02083"></a>02083 
<a name="l02084"></a>02084   <span class="keywordflow">if</span>(cache_status != <a class="code" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2a3fdbbb2367268ae84ac11d7b189643d8">CACHE_INODE_SUCCESS</a>)
<a name="l02085"></a>02085     {
<a name="l02086"></a>02086       *pstatus = <a class="code" href="sal__functions_8h.html#a8edcc5485a600a2f7d798bcdd33fdb09">cache_inode_status_to_state_status</a>(cache_status);
<a name="l02087"></a>02087       <a class="code" href="log_8h.html#aa7aee8ec65b5baafb430f8d2a7588d53">LogDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02088"></a>02088                <span class="stringliteral">&quot;Could not pin file&quot;</span>);
<a name="l02089"></a>02089       <span class="keywordflow">return</span> *pstatus;
<a name="l02090"></a>02090     }
<a name="l02091"></a>02091 
<a name="l02092"></a>02092   <span class="keywordflow">if</span>(<a class="code" href="cache__inode__open__close_8c.html#a396684171093081bc52283a6030e6267" title="Opens a file descriptor.">cache_inode_open</a>(pentry, <a class="code" href="fsal__types_8h.html#a2f41a66ed7ecd8494344eff0f56f3784">FSAL_O_RDWR</a>, pcontext, 0, &amp;cache_status) != <a class="code" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2a3fdbbb2367268ae84ac11d7b189643d8">CACHE_INODE_SUCCESS</a>)
<a name="l02093"></a>02093     {
<a name="l02094"></a>02094       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02095"></a>02095       *pstatus = <a class="code" href="sal__functions_8h.html#a8edcc5485a600a2f7d798bcdd33fdb09">cache_inode_status_to_state_status</a>(cache_status);
<a name="l02096"></a>02096       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02097"></a>02097                    <span class="stringliteral">&quot;Could not open file&quot;</span>);
<a name="l02098"></a>02098       <span class="keywordflow">return</span> *pstatus;
<a name="l02099"></a>02099     }
<a name="l02100"></a>02100 
<a name="l02101"></a>02101   pthread_rwlock_wrlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02102"></a>02102 
<a name="l02103"></a>02103 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l02104"></a>02104 <span class="preprocessor"></span>
<a name="l02105"></a>02105   <span class="keywordflow">if</span>(blocking != <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8facf0a49c1e4b5d2ab379c0b9c61df625d">STATE_NON_BLOCKING</a>)
<a name="l02106"></a>02106     {
<a name="l02107"></a>02107       <span class="comment">/*</span>
<a name="l02108"></a>02108 <span class="comment">       * First search for a blocked request. Client can ignore the blocked</span>
<a name="l02109"></a>02109 <span class="comment">       * request and keep sending us new lock request again and again. So if</span>
<a name="l02110"></a>02110 <span class="comment">       * we have a mapping blocked request return that</span>
<a name="l02111"></a>02111 <span class="comment">       */</span>
<a name="l02112"></a>02112       <a class="code" href="nlm__list_8h.html#a39dd5015f511354bf29ba3cec9a3987b">glist_for_each</a>(glist, &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list)
<a name="l02113"></a>02113         {
<a name="l02114"></a>02114           found_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l02115"></a>02115 
<a name="l02116"></a>02116           <span class="keywordflow">if</span>(<a class="code" href="sal__functions_8h.html#aafafe1a716e741dd5d3a2b3f579ddb94">different_owners</a>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>, powner))
<a name="l02117"></a>02117             <span class="keywordflow">continue</span>;
<a name="l02118"></a>02118 
<a name="l02119"></a>02119           <span class="comment">/* Need to reject lock request if this lock owner already has a lock</span>
<a name="l02120"></a>02120 <span class="comment">           * on this file via a different export.</span>
<a name="l02121"></a>02121 <span class="comment">           */</span>
<a name="l02122"></a>02122           <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a> != pexport)
<a name="l02123"></a>02123             {
<a name="l02124"></a>02124               pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02125"></a>02125 
<a name="l02126"></a>02126               <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02127"></a>02127 
<a name="l02128"></a>02128               <a class="code" href="log_8h.html#a014a663a4d20c38e82ab3f35298667e8">LogEvent</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02129"></a>02129                        <span class="stringliteral">&quot;Lock Owner Export Conflict, Lock held for export %d (%s), request for export %d (%s)&quot;</span>,
<a name="l02130"></a>02130                        found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>-&gt;<a class="code" href="structexportlist____.html#a6cdf6b3326db83e0af2976000c374b12">id</a>,
<a name="l02131"></a>02131                        found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>-&gt;<a class="code" href="structexportlist____.html#a9f5261f3f2aa4e10232d3e7fae0f3e27">fullpath</a>,
<a name="l02132"></a>02132                        pexport-&gt;<a class="code" href="structexportlist____.html#a6cdf6b3326db83e0af2976000c374b12">id</a>,
<a name="l02133"></a>02133                        pexport-&gt;<a class="code" href="structexportlist____.html#a9f5261f3f2aa4e10232d3e7fae0f3e27">fullpath</a>);
<a name="l02134"></a>02134               LogEntry(<span class="stringliteral">&quot;Found lock entry belonging to another export&quot;</span>, found_entry);
<a name="l02135"></a>02135               *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba76c2642cf318679a6455f2e5cb49909d">STATE_INVALID_ARGUMENT</a>;
<a name="l02136"></a>02136               <span class="keywordflow">return</span> *pstatus;
<a name="l02137"></a>02137             }
<a name="l02138"></a>02138 
<a name="l02139"></a>02139           <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> != blocking)
<a name="l02140"></a>02140             <span class="keywordflow">continue</span>;
<a name="l02141"></a>02141 
<a name="l02142"></a>02142           <span class="keywordflow">if</span>(different_lock(&amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>, plock))
<a name="l02143"></a>02143             <span class="keywordflow">continue</span>;
<a name="l02144"></a>02144 
<a name="l02145"></a>02145           pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02146"></a>02146 
<a name="l02147"></a>02147           <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02148"></a>02148 
<a name="l02149"></a>02149           <span class="comment">/*</span>
<a name="l02150"></a>02150 <span class="comment">           * We have matched all atribute of the existing lock.</span>
<a name="l02151"></a>02151 <span class="comment">           * Just return with blocked status. Client may be polling.</span>
<a name="l02152"></a>02152 <span class="comment">           */</span>
<a name="l02153"></a>02153           LogEntry(<span class="stringliteral">&quot;Found blocked&quot;</span>, found_entry);
<a name="l02154"></a>02154           *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5badd826dce2e924f2a4b52b320e2271546">STATE_LOCK_BLOCKED</a>;
<a name="l02155"></a>02155           <span class="keywordflow">return</span> *pstatus;
<a name="l02156"></a>02156         }
<a name="l02157"></a>02157     }
<a name="l02158"></a>02158 <span class="preprocessor">#endif</span>
<a name="l02159"></a>02159 <span class="preprocessor"></span>
<a name="l02160"></a>02160   <a class="code" href="nlm__list_8h.html#a39dd5015f511354bf29ba3cec9a3987b">glist_for_each</a>(glist, &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list)
<a name="l02161"></a>02161     {
<a name="l02162"></a>02162       found_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l02163"></a>02163 
<a name="l02164"></a>02164       <span class="comment">/* Need to reject lock request if this lock owner already has a lock</span>
<a name="l02165"></a>02165 <span class="comment">       * on this file via a different export.</span>
<a name="l02166"></a>02166 <span class="comment">       */</span>
<a name="l02167"></a>02167       <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a> != pexport &amp;&amp;
<a name="l02168"></a>02168          !<a class="code" href="sal__functions_8h.html#aafafe1a716e741dd5d3a2b3f579ddb94">different_owners</a>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>, powner))
<a name="l02169"></a>02169         {
<a name="l02170"></a>02170           pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02171"></a>02171 
<a name="l02172"></a>02172           <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02173"></a>02173 
<a name="l02174"></a>02174           <a class="code" href="log_8h.html#a014a663a4d20c38e82ab3f35298667e8">LogEvent</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02175"></a>02175                    <span class="stringliteral">&quot;Lock Owner Export Conflict, Lock held for export %d (%s), request for export %d (%s)&quot;</span>,
<a name="l02176"></a>02176                    found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>-&gt;<a class="code" href="structexportlist____.html#a6cdf6b3326db83e0af2976000c374b12">id</a>,
<a name="l02177"></a>02177                    found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>-&gt;<a class="code" href="structexportlist____.html#a9f5261f3f2aa4e10232d3e7fae0f3e27">fullpath</a>,
<a name="l02178"></a>02178                    pexport-&gt;<a class="code" href="structexportlist____.html#a6cdf6b3326db83e0af2976000c374b12">id</a>,
<a name="l02179"></a>02179                    pexport-&gt;<a class="code" href="structexportlist____.html#a9f5261f3f2aa4e10232d3e7fae0f3e27">fullpath</a>);
<a name="l02180"></a>02180 
<a name="l02181"></a>02181           LogEntry(<span class="stringliteral">&quot;Found lock entry belonging to another export&quot;</span>, found_entry);
<a name="l02182"></a>02182 
<a name="l02183"></a>02183           *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba76c2642cf318679a6455f2e5cb49909d">STATE_INVALID_ARGUMENT</a>;
<a name="l02184"></a>02184           <span class="keywordflow">return</span> *pstatus;
<a name="l02185"></a>02185         }
<a name="l02186"></a>02186 
<a name="l02187"></a>02187       <span class="comment">/* Don&#39;t skip blocked locks for fairness */</span>
<a name="l02188"></a>02188 
<a name="l02189"></a>02189       found_entry_end = <a class="code" href="nlm__util_8c.html#a60b7d2de12c53886bcb1ccdde38de77e">lock_end</a>(&amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>);
<a name="l02190"></a>02190 
<a name="l02191"></a>02191       <span class="keywordflow">if</span>((found_entry_end &gt;= plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>) &amp;&amp;
<a name="l02192"></a>02192          (found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> &lt;= plock_end))
<a name="l02193"></a>02193         {
<a name="l02194"></a>02194           <span class="comment">/* lock overlaps see if we can allow</span>
<a name="l02195"></a>02195 <span class="comment">           * allow if neither lock is exclusive or the owner is the same</span>
<a name="l02196"></a>02196 <span class="comment">           */</span>
<a name="l02197"></a>02197           <span class="keywordflow">if</span>((found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a> == <a class="code" href="fsal__types_8h.html#aab76e308a0e07a7fcb4f4182ca3c098ca26e942e5ccc850086303fb166d2e1624">FSAL_LOCK_W</a> ||
<a name="l02198"></a>02198               plock-&gt;<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a> == <a class="code" href="fsal__types_8h.html#aab76e308a0e07a7fcb4f4182ca3c098ca26e942e5ccc850086303fb166d2e1624">FSAL_LOCK_W</a>) &amp;&amp;
<a name="l02199"></a>02199              <a class="code" href="sal__functions_8h.html#aafafe1a716e741dd5d3a2b3f579ddb94">different_owners</a>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>, powner))
<a name="l02200"></a>02200             {
<a name="l02201"></a>02201               <span class="comment">/* Found a conflicting lock, break out of loop.</span>
<a name="l02202"></a>02202 <span class="comment">               * Also indicate overlap hint.</span>
<a name="l02203"></a>02203 <span class="comment">               */</span>
<a name="l02204"></a>02204               LogEntry(<span class="stringliteral">&quot;Conflicts with&quot;</span>, found_entry);
<a name="l02205"></a>02205               LogList(<span class="stringliteral">&quot;Locks&quot;</span>, pentry, &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list);
<a name="l02206"></a>02206               <a class="code" href="state__lock_8c.html#a3a32bdf5e3fb16345539e2b0a37941ce">copy_conflict</a>(found_entry, holder, conflict);
<a name="l02207"></a>02207               allow   = <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l02208"></a>02208               overlap = <a class="code" href="HashTable_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l02209"></a>02209               <span class="keywordflow">break</span>;
<a name="l02210"></a>02210             }
<a name="l02211"></a>02211         }
<a name="l02212"></a>02212 
<a name="l02213"></a>02213       <span class="keywordflow">if</span>(found_entry_end &gt;= plock_end &amp;&amp;
<a name="l02214"></a>02214          found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> &lt;= plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> &amp;&amp;
<a name="l02215"></a>02215          found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>.<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a> == plock-&gt;<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a> &amp;&amp;
<a name="l02216"></a>02216          (found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> == <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8facf0a49c1e4b5d2ab379c0b9c61df625d">STATE_NON_BLOCKING</a> ||
<a name="l02217"></a>02217           found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> == <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa90ad1f35643849c6891a9fda17568fd9">STATE_GRANTING</a>))
<a name="l02218"></a>02218         {
<a name="l02219"></a>02219           <span class="comment">/* Found an entry that entirely overlaps the new entry</span>
<a name="l02220"></a>02220 <span class="comment">           * (and due to the preceding test does not prevent</span>
<a name="l02221"></a>02221 <span class="comment">           * granting this lock - therefore there can&#39;t be any</span>
<a name="l02222"></a>02222 <span class="comment">           * other locks that would prevent granting this lock</span>
<a name="l02223"></a>02223 <span class="comment">           */</span>
<a name="l02224"></a>02224           <span class="keywordflow">if</span>(!<a class="code" href="sal__functions_8h.html#aafafe1a716e741dd5d3a2b3f579ddb94">different_owners</a>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>, powner))
<a name="l02225"></a>02225             {
<a name="l02226"></a>02226 <span class="preprocessor"> #ifdef _USE_BLOCKING_LOCKS</span>
<a name="l02227"></a>02227 <span class="preprocessor"></span>             <span class="comment">/* The lock actually has the same owner, we&#39;re done,</span>
<a name="l02228"></a>02228 <span class="comment">              * other than dealing with a lock in GRANTING state.</span>
<a name="l02229"></a>02229 <span class="comment">              */</span>
<a name="l02230"></a>02230               <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> == <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa90ad1f35643849c6891a9fda17568fd9">STATE_GRANTING</a>)
<a name="l02231"></a>02231                 {
<a name="l02232"></a>02232                   <span class="comment">/* Need to handle completion of granting of this lock</span>
<a name="l02233"></a>02233 <span class="comment">                   * because a GRANT was in progress.</span>
<a name="l02234"></a>02234 <span class="comment">                   * This could be a client retrying a blocked lock</span>
<a name="l02235"></a>02235 <span class="comment">                   * due to mis-trust of server. If the client</span>
<a name="l02236"></a>02236 <span class="comment">                   * also accepts the GRANT_MSG with a GRANT_RESP,</span>
<a name="l02237"></a>02237 <span class="comment">                   * that will be just fine.</span>
<a name="l02238"></a>02238 <span class="comment">                   */</span>
<a name="l02239"></a>02239                   grant_blocked_lock_immediate(pentry,
<a name="l02240"></a>02240                                                pcontext,
<a name="l02241"></a>02241                                                found_entry);
<a name="l02242"></a>02242                 }
<a name="l02243"></a>02243 <span class="preprocessor">#endif</span>
<a name="l02244"></a>02244 <span class="preprocessor"></span>              pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02245"></a>02245 
<a name="l02246"></a>02246               <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02247"></a>02247 
<a name="l02248"></a>02248               LogEntry(<span class="stringliteral">&quot;Found existing&quot;</span>, found_entry);
<a name="l02249"></a>02249 
<a name="l02250"></a>02250               *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l02251"></a>02251               <span class="keywordflow">return</span> *pstatus;
<a name="l02252"></a>02252             }
<a name="l02253"></a>02253 
<a name="l02254"></a>02254           <span class="comment">/* Found a compatible lock with a different lock owner that</span>
<a name="l02255"></a>02255 <span class="comment">           * fully overlaps, set hint.</span>
<a name="l02256"></a>02256 <span class="comment">           */</span>
<a name="l02257"></a>02257           LogEntry(<span class="stringliteral">&quot;state_lock Found overlapping&quot;</span>, found_entry);
<a name="l02258"></a>02258           overlap = <a class="code" href="HashTable_8c.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l02259"></a>02259         }
<a name="l02260"></a>02260     }
<a name="l02261"></a>02261 
<a name="l02262"></a>02262   <span class="comment">/* Decide how to proceed */</span>
<a name="l02263"></a>02263   <span class="keywordflow">if</span>(pstatic-&gt;<a class="code" href="structfsal__staticfsinfo__t.html#a2d6d73987342316ef0a250af1941a6b5">lock_support_async_block</a> &amp;&amp; blocking == <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa1f8b0da78f5ae271f0ff4c1ed4faf586">STATE_NLM_BLOCKING</a>)
<a name="l02264"></a>02264     {
<a name="l02265"></a>02265       <span class="comment">/* FSAL supports blocking locks, and this is an NLM blocking lock request,</span>
<a name="l02266"></a>02266 <span class="comment">       * request blocking lock from FSAL.</span>
<a name="l02267"></a>02267 <span class="comment">       */</span>
<a name="l02268"></a>02268       lock_op = <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a441819d7daf06f76149039b2f862fe09">FSAL_OP_LOCKB</a>;
<a name="l02269"></a>02269     }
<a name="l02270"></a>02270   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(allow || blocking == <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8fa1f8b0da78f5ae271f0ff4c1ed4faf586">STATE_NLM_BLOCKING</a>)
<a name="l02271"></a>02271     {
<a name="l02272"></a>02272       <span class="comment">/* No conflict found in Ganesha, or NLM blocking lock when FSAL doesn&#39;t</span>
<a name="l02273"></a>02273 <span class="comment">       * support blocking locks. In either case, proceed with non-blocking</span>
<a name="l02274"></a>02274 <span class="comment">       * request to FSAL.</span>
<a name="l02275"></a>02275 <span class="comment">       */</span>
<a name="l02276"></a>02276       lock_op = <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a6b55656aca96aac5afa516294b42607c">FSAL_OP_LOCK</a>;
<a name="l02277"></a>02277     }
<a name="l02278"></a>02278   <span class="keywordflow">else</span>
<a name="l02279"></a>02279     {
<a name="l02280"></a>02280       <span class="comment">/* Can&#39;t do async blocking lock in FSAL and have a conflict.</span>
<a name="l02281"></a>02281 <span class="comment">       * Return it.</span>
<a name="l02282"></a>02282 <span class="comment">       */</span>
<a name="l02283"></a>02283       pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02284"></a>02284 
<a name="l02285"></a>02285       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02286"></a>02286 
<a name="l02287"></a>02287       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5baca81ee684ca3b8423644fc1e8e5031fe">STATE_LOCK_CONFLICT</a>;
<a name="l02288"></a>02288       <span class="keywordflow">return</span> *pstatus;
<a name="l02289"></a>02289     }
<a name="l02290"></a>02290 
<a name="l02291"></a>02291   <span class="comment">/* We have already returned if:</span>
<a name="l02292"></a>02292 <span class="comment">   * + we have found an identical blocking lock</span>
<a name="l02293"></a>02293 <span class="comment">   * + we have found an entirely overlapping lock with the same lock owner</span>
<a name="l02294"></a>02294 <span class="comment">   * + this was not a supported blocking lock and we found a conflict</span>
<a name="l02295"></a>02295 <span class="comment">   *</span>
<a name="l02296"></a>02296 <span class="comment">   * So at this point, we are either going to do one of the following (all</span>
<a name="l02297"></a>02297 <span class="comment">   * descriptions below assume no problems occur):</span>
<a name="l02298"></a>02298 <span class="comment">   *</span>
<a name="l02299"></a>02299 <span class="comment">   * (1) FSAL supports async blocking locks, we know there is a conflict, and</span>
<a name="l02300"></a>02300 <span class="comment">   *     this is a supported blocking lock request</span>
<a name="l02301"></a>02301 <span class="comment">   *</span>
<a name="l02302"></a>02302 <span class="comment">   *     Make FSAL_OP_LOCKB call anyway, we will rely on FSAL to grant blocking</span>
<a name="l02303"></a>02303 <span class="comment">   *     locks. We will return the conflict we know about rather than what the</span>
<a name="l02304"></a>02304 <span class="comment">   *     FSAL returns. Insert blocking lock into queue.</span>
<a name="l02305"></a>02305 <span class="comment">   *</span>
<a name="l02306"></a>02306 <span class="comment">   * (2) FSAL supports async blocking locks, we don&#39;t know about any conflict,</span>
<a name="l02307"></a>02307 <span class="comment">   *     and this is a supported blocking lock request</span>
<a name="l02308"></a>02308 <span class="comment">   *</span>
<a name="l02309"></a>02309 <span class="comment">   *     Make FSAL_OP_LOCKB call, if it indicates block, insert blocking lock</span>
<a name="l02310"></a>02310 <span class="comment">   *     into queue, and return the conflict the FSAL indicates. If FSAL grants</span>
<a name="l02311"></a>02311 <span class="comment">   *     lock, then return granted lock and insert into lock list, otherwise</span>
<a name="l02312"></a>02312 <span class="comment">   *     insert blocking lock into queue.</span>
<a name="l02313"></a>02313 <span class="comment">   *</span>
<a name="l02314"></a>02314 <span class="comment">   * (3) FSAL doesn&#39;t support async blocking locks, this is a supported blocking</span>
<a name="l02315"></a>02315 <span class="comment">   *     lock and we know there is a conflict</span>
<a name="l02316"></a>02316 <span class="comment">   *</span>
<a name="l02317"></a>02317 <span class="comment">   *     Insert blocking lock into queue, we will grant lock when possible.</span>
<a name="l02318"></a>02318 <span class="comment">   *</span>
<a name="l02319"></a>02319 <span class="comment">   * (4) FSAL doesn&#39;t support async blocking locks and we don&#39;t know about any</span>
<a name="l02320"></a>02320 <span class="comment">   *     conflict</span>
<a name="l02321"></a>02321 <span class="comment">   *</span>
<a name="l02322"></a>02322 <span class="comment">   *     Make FSAL_OP_LOCK call, if it indicates conflict, return that. Even if</span>
<a name="l02323"></a>02323 <span class="comment">   *     this is a supported blocking lock call, there is no way to block. If</span>
<a name="l02324"></a>02324 <span class="comment">   *     lock is granted, return that and insert lock into list.</span>
<a name="l02325"></a>02325 <span class="comment">   *</span>
<a name="l02326"></a>02326 <span class="comment">   * (5) FSAL supports async blocking locks, we don&#39;t know about any conflict,</span>
<a name="l02327"></a>02327 <span class="comment">   *     and this is not a supported blocking lock request</span>
<a name="l02328"></a>02328 <span class="comment">   *</span>
<a name="l02329"></a>02329 <span class="comment">   *     Make FSAL_OP_LOCK call, if it indicates conflict, return that. If</span>
<a name="l02330"></a>02330 <span class="comment">   *     lock is granted, return that and insert lock into list.</span>
<a name="l02331"></a>02331 <span class="comment">   */</span>
<a name="l02332"></a>02332 
<a name="l02333"></a>02333   <span class="comment">/* Create the new lock entry.</span>
<a name="l02334"></a>02334 <span class="comment">   * Provisionally mark this lock as granted.</span>
<a name="l02335"></a>02335 <span class="comment">   */</span>
<a name="l02336"></a>02336   found_entry = create_state_lock_entry(pentry,
<a name="l02337"></a>02337                                         pcontext,
<a name="l02338"></a>02338                                         pexport,
<a name="l02339"></a>02339                                         <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8facf0a49c1e4b5d2ab379c0b9c61df625d">STATE_NON_BLOCKING</a>,
<a name="l02340"></a>02340                                         powner,
<a name="l02341"></a>02341                                         pstate,
<a name="l02342"></a>02342                                         plock);
<a name="l02343"></a>02343   <span class="keywordflow">if</span>(!found_entry)
<a name="l02344"></a>02344     {
<a name="l02345"></a>02345       pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02346"></a>02346 
<a name="l02347"></a>02347       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02348"></a>02348 
<a name="l02349"></a>02349       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba83de6e519398c6a0377256b70f1d58fc">STATE_MALLOC_ERROR</a>;
<a name="l02350"></a>02350       <span class="keywordflow">return</span> *pstatus;
<a name="l02351"></a>02351     }
<a name="l02352"></a>02352 
<a name="l02353"></a>02353   <span class="comment">/* If no conflict in lock list, or FSAL supports async blocking locks,</span>
<a name="l02354"></a>02354 <span class="comment">   * make FSAL call. Don&#39;t ask for conflict if we know about a conflict.</span>
<a name="l02355"></a>02355 <span class="comment">   */</span>
<a name="l02356"></a>02356   <span class="keywordflow">if</span>(allow || pstatic-&gt;<a class="code" href="structfsal__staticfsinfo__t.html#a2d6d73987342316ef0a250af1941a6b5">lock_support_async_block</a>)
<a name="l02357"></a>02357     {
<a name="l02358"></a>02358       <span class="comment">/* Prepare to make call to FSAL for this lock */</span>
<a name="l02359"></a>02359       *pstatus = <a class="code" href="state__lock_8c.html#a1b7532d0b0321fdd328c9057087b1cfb">do_lock_op</a>(pentry,
<a name="l02360"></a>02360                             pcontext,
<a name="l02361"></a>02361                             pexport,
<a name="l02362"></a>02362                             lock_op,
<a name="l02363"></a>02363                             powner,
<a name="l02364"></a>02364                             plock,
<a name="l02365"></a>02365                             allow ? holder : <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l02366"></a>02366                             allow ? conflict : NULL,
<a name="l02367"></a>02367                             overlap);
<a name="l02368"></a>02368     }
<a name="l02369"></a>02369   <span class="keywordflow">else</span>
<a name="l02370"></a>02370     *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5badd826dce2e924f2a4b52b320e2271546">STATE_LOCK_BLOCKED</a>;
<a name="l02371"></a>02371 
<a name="l02372"></a>02372   <span class="keywordflow">if</span>(*pstatus == <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l02373"></a>02373     {
<a name="l02374"></a>02374       <span class="comment">/* Merge any touching or overlapping locks into this one */</span>
<a name="l02375"></a>02375       LogEntry(<span class="stringliteral">&quot;FSAL lock acquired, merging locks for&quot;</span>, found_entry);
<a name="l02376"></a>02376 
<a name="l02377"></a>02377       merge_lock_entry(pentry, pcontext, found_entry);
<a name="l02378"></a>02378 
<a name="l02379"></a>02379       <span class="comment">/* Insert entry into lock list */</span>
<a name="l02380"></a>02380       LogEntry(<span class="stringliteral">&quot;New&quot;</span>, found_entry);
<a name="l02381"></a>02381 
<a name="l02382"></a>02382       <span class="comment">/* if the list is empty to start with; increment the pin ref count</span>
<a name="l02383"></a>02383 <span class="comment">       * before adding it to the list</span>
<a name="l02384"></a>02384 <span class="comment">       */</span>
<a name="l02385"></a>02385       <span class="keywordflow">if</span>(glist_empty(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list))
<a name="l02386"></a>02386           <a class="code" href="cache__inode__lru_8c.html#a96bb243e361cf38c5ae8ac4c50c108f1" title="Function to let the state layer pin an entry.">cache_inode_inc_pin_ref</a>(pentry);
<a name="l02387"></a>02387 
<a name="l02388"></a>02388       glist_add_tail(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list, &amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#ae87ceb436fd9f2ee0fbc19f454d74d52">sle_list</a>);
<a name="l02389"></a>02389 
<a name="l02390"></a>02390 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l02391"></a>02391 <span class="preprocessor"></span>      <span class="comment">/* A lock downgrade could unblock blocked locks */</span>
<a name="l02392"></a>02392       grant_blocked_locks(pentry, pcontext);
<a name="l02393"></a>02393 <span class="preprocessor">#endif</span>
<a name="l02394"></a>02394 <span class="preprocessor"></span>      <span class="comment">/* Don&#39;t need to unpin, we know there is state on file. */</span>
<a name="l02395"></a>02395     }
<a name="l02396"></a>02396   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(*pstatus == <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5baca81ee684ca3b8423644fc1e8e5031fe">STATE_LOCK_CONFLICT</a>)
<a name="l02397"></a>02397     {
<a name="l02398"></a>02398       LogEntry(<span class="stringliteral">&quot;Conflict in FSAL for&quot;</span>, found_entry);
<a name="l02399"></a>02399 
<a name="l02400"></a>02400       <span class="comment">/* Discard lock entry */</span>
<a name="l02401"></a>02401       remove_from_locklist(found_entry);
<a name="l02402"></a>02402     }
<a name="l02403"></a>02403 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l02404"></a>02404 <span class="preprocessor"></span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(*pstatus == <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5badd826dce2e924f2a4b52b320e2271546">STATE_LOCK_BLOCKED</a>)
<a name="l02405"></a>02405     {
<a name="l02406"></a>02406       <span class="comment">/* Mark entry as blocking and attach block_data */</span>
<a name="l02407"></a>02407       found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abf169f4225e3c1887d46f426afbb3de5">sle_block_data</a> = block_data;
<a name="l02408"></a>02408       found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a>    = blocking;
<a name="l02409"></a>02409       block_data-&gt;sbd_lock_entry  = found_entry;
<a name="l02410"></a>02410 
<a name="l02411"></a>02411       <span class="comment">/* Insert entry into lock list */</span>
<a name="l02412"></a>02412       LogEntry(<span class="stringliteral">&quot;FSAL block for&quot;</span>, found_entry);
<a name="l02413"></a>02413 
<a name="l02414"></a>02414       <span class="comment">/* if the list is empty to start with; increment the pin ref count</span>
<a name="l02415"></a>02415 <span class="comment">       * before adding it to the list</span>
<a name="l02416"></a>02416 <span class="comment">       */</span>
<a name="l02417"></a>02417       <span class="keywordflow">if</span>(glist_empty(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list))
<a name="l02418"></a>02418           <a class="code" href="cache__inode__lru_8c.html#a96bb243e361cf38c5ae8ac4c50c108f1" title="Function to let the state layer pin an entry.">cache_inode_inc_pin_ref</a>(pentry);
<a name="l02419"></a>02419 
<a name="l02420"></a>02420       glist_add_tail(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list, &amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#ae87ceb436fd9f2ee0fbc19f454d74d52">sle_list</a>);
<a name="l02421"></a>02421 
<a name="l02422"></a>02422       pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02423"></a>02423 
<a name="l02424"></a>02424       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02425"></a>02425 
<a name="l02426"></a>02426       <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(blocked_locks_mutex);
<a name="l02427"></a>02427 
<a name="l02428"></a>02428       glist_add_tail(&amp;state_blocked_locks, &amp;block_data-&gt;sbd_list);
<a name="l02429"></a>02429 
<a name="l02430"></a>02430       <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(blocked_locks_mutex);
<a name="l02431"></a>02431 
<a name="l02432"></a>02432       <span class="keywordflow">return</span> *pstatus;
<a name="l02433"></a>02433     }
<a name="l02434"></a>02434 <span class="preprocessor">#endif </span><span class="comment">/* _USE_BLOCKING_LOCKS */</span>
<a name="l02435"></a>02435   <span class="keywordflow">else</span>
<a name="l02436"></a>02436     {
<a name="l02437"></a>02437       <a class="code" href="log_8h.html#a3cf3c22fac6bb9871e25007551caeb13">LogMajor</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02438"></a>02438                <span class="stringliteral">&quot;Unable to lock FSAL, error=%s&quot;</span>,
<a name="l02439"></a>02439                <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(*pstatus));
<a name="l02440"></a>02440 
<a name="l02441"></a>02441       <span class="comment">/* Discard lock entry */</span>
<a name="l02442"></a>02442       remove_from_locklist(found_entry);
<a name="l02443"></a>02443     }
<a name="l02444"></a>02444 
<a name="l02445"></a>02445   pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02446"></a>02446 
<a name="l02447"></a>02447   <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02448"></a>02448 
<a name="l02449"></a>02449   <span class="keywordflow">return</span> *pstatus;
<a name="l02450"></a>02450 }
<a name="l02451"></a>02451 
<a name="l02457"></a><a class="code" href="state__lock_8c.html#a4d80449370d509288b5e94bca7944324">02457</a> <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> <a class="code" href="sal__functions_8h.html#a4d80449370d509288b5e94bca7944324">state_unlock</a>(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l02458"></a>02458                             <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l02459"></a>02459                             <a class="code" href="structexportlist____.html">exportlist_t</a>         * pexport,
<a name="l02460"></a>02460                             <a class="code" href="structstate__owner__t.html">state_owner_t</a>        * powner,
<a name="l02461"></a>02461                             <a class="code" href="structstate__t.html">state_t</a>              * pstate,
<a name="l02462"></a>02462                             <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * plock,
<a name="l02463"></a>02463                             <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>       * pstatus)
<a name="l02464"></a>02464 {
<a name="l02465"></a>02465   bool_t                 empty = <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l02466"></a>02466   <a class="code" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a>   cache_status;
<a name="l02467"></a>02467 
<a name="l02468"></a>02468   cache_status = <a class="code" href="cache__inode__lru_8c.html#a96bb243e361cf38c5ae8ac4c50c108f1" title="Function to let the state layer pin an entry.">cache_inode_inc_pin_ref</a>(pentry);
<a name="l02469"></a>02469 
<a name="l02470"></a>02470   <span class="keywordflow">if</span>(cache_status != <a class="code" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2a3fdbbb2367268ae84ac11d7b189643d8">CACHE_INODE_SUCCESS</a>)
<a name="l02471"></a>02471     {
<a name="l02472"></a>02472       *pstatus = <a class="code" href="sal__functions_8h.html#a8edcc5485a600a2f7d798bcdd33fdb09">cache_inode_status_to_state_status</a>(cache_status);
<a name="l02473"></a>02473       <a class="code" href="log_8h.html#aa7aee8ec65b5baafb430f8d2a7588d53">LogDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02474"></a>02474                <span class="stringliteral">&quot;Could not pin file&quot;</span>);
<a name="l02475"></a>02475       <span class="keywordflow">return</span> *pstatus;
<a name="l02476"></a>02476     }
<a name="l02477"></a>02477 
<a name="l02478"></a>02478   <span class="keywordflow">if</span>(pentry-&gt;<a class="code" href="structcache__entry__t.html#afa60c075430da0dbe9d5f4160f336294">type</a> != <a class="code" href="cache__inode_8h.html#a2aee8d2ff73574138b75922c7652162fa00512007115c06f83e278302d7c70590">REGULAR_FILE</a>)
<a name="l02479"></a>02479     {
<a name="l02480"></a>02480       <a class="code" href="sal__functions_8h.html#ad62a073d73c565a7d2bbc850bc16e617">LogLock</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <a class="code" href="log_8h.html#afc14b587b4225c84f4796397df9489e2aef0a258add3e3716c5776b34656b18ed">NIV_DEBUG</a>,
<a name="l02481"></a>02481               <span class="stringliteral">&quot;Bad Unlock&quot;</span>,
<a name="l02482"></a>02482               pentry, pcontext, powner, plock);
<a name="l02483"></a>02483       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba20ad4ad7596b102c028c12cf9821b710">STATE_BAD_TYPE</a>;
<a name="l02484"></a>02484       <span class="keywordflow">return</span> *pstatus;
<a name="l02485"></a>02485     }
<a name="l02486"></a>02486 
<a name="l02487"></a>02487   <span class="comment">/* We need to iterate over the full lock list and remove</span>
<a name="l02488"></a>02488 <span class="comment">   * any mapping entry. And sle_lock.lock_start = 0 and sle_lock.lock_length = 0 nlm_lock</span>
<a name="l02489"></a>02489 <span class="comment">   * implies remove all entries</span>
<a name="l02490"></a>02490 <span class="comment">   */</span>
<a name="l02491"></a>02491   pthread_rwlock_wrlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02492"></a>02492 
<a name="l02493"></a>02493   <span class="comment">/* If lock list is empty, there really isn&#39;t any work for us to do. */</span>
<a name="l02494"></a>02494   <span class="keywordflow">if</span>(glist_empty(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list))
<a name="l02495"></a>02495     {
<a name="l02496"></a>02496       pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02497"></a>02497 
<a name="l02498"></a>02498       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02499"></a>02499       <a class="code" href="log_8h.html#aa7aee8ec65b5baafb430f8d2a7588d53">LogDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02500"></a>02500                <span class="stringliteral">&quot;Unlock success on file with no locks&quot;</span>);
<a name="l02501"></a>02501 
<a name="l02502"></a>02502       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l02503"></a>02503       <span class="keywordflow">return</span> *pstatus;
<a name="l02504"></a>02504     }
<a name="l02505"></a>02505 
<a name="l02506"></a>02506   <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02507"></a>02507                <span class="stringliteral">&quot;----------------------------------------------------------------------&quot;</span>);
<a name="l02508"></a>02508   <a class="code" href="sal__functions_8h.html#ad62a073d73c565a7d2bbc850bc16e617">LogLock</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <a class="code" href="log_8h.html#afc14b587b4225c84f4796397df9489e2a59e3d6a98085b3dc7f143072242d2485">NIV_FULL_DEBUG</a>,
<a name="l02509"></a>02509           <span class="stringliteral">&quot;Subtracting&quot;</span>,
<a name="l02510"></a>02510           pentry, pcontext, powner, plock);
<a name="l02511"></a>02511   <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02512"></a>02512                <span class="stringliteral">&quot;----------------------------------------------------------------------&quot;</span>);
<a name="l02513"></a>02513 
<a name="l02514"></a>02514 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l02515"></a>02515 <span class="preprocessor"></span>  <span class="comment">/* First cancel any blocking locks that might overlap the unlocked range. */</span>
<a name="l02516"></a>02516   cancel_blocked_locks_range(pentry,
<a name="l02517"></a>02517                              pcontext,
<a name="l02518"></a>02518                              powner,
<a name="l02519"></a>02519                              pstate,
<a name="l02520"></a>02520                              plock);
<a name="l02521"></a>02521 <span class="preprocessor">#endif</span>
<a name="l02522"></a>02522 <span class="preprocessor"></span>
<a name="l02523"></a>02523   <span class="comment">/* Release the lock from cache inode lock list for pentry */</span>
<a name="l02524"></a>02524   subtract_lock_from_list(pentry,
<a name="l02525"></a>02525                           pcontext,
<a name="l02526"></a>02526                           powner,
<a name="l02527"></a>02527                           pstate,
<a name="l02528"></a>02528                           plock,
<a name="l02529"></a>02529                           pstatus,
<a name="l02530"></a>02530                           &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list);
<a name="l02531"></a>02531 
<a name="l02532"></a>02532   <span class="keywordflow">if</span>(*pstatus != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l02533"></a>02533     {
<a name="l02534"></a>02534       <span class="comment">/* The unlock has not taken affect (other than canceling any blocking locks. */</span>
<a name="l02535"></a>02535       <a class="code" href="log_8h.html#a3cf3c22fac6bb9871e25007551caeb13">LogMajor</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02536"></a>02536                <span class="stringliteral">&quot;Unable to remove lock from list for unlock, error=%s&quot;</span>,
<a name="l02537"></a>02537                <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(*pstatus));
<a name="l02538"></a>02538 
<a name="l02539"></a>02539       pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02540"></a>02540 
<a name="l02541"></a>02541       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02542"></a>02542 
<a name="l02543"></a>02543       <span class="keywordflow">return</span> *pstatus;
<a name="l02544"></a>02544     }
<a name="l02545"></a>02545 
<a name="l02546"></a>02546   <span class="comment">/* If the lock list has become zero; decrement the pin ref count pt placed */</span>
<a name="l02547"></a>02547   <span class="keywordflow">if</span>(glist_empty(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list))
<a name="l02548"></a>02548       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02549"></a>02549 
<a name="l02550"></a>02550 
<a name="l02551"></a>02551   <span class="comment">/* Unlocking the entire region will remove any FSAL locks we held, whether</span>
<a name="l02552"></a>02552 <span class="comment">   * from fully granted locks, or from blocking locks that were in the process</span>
<a name="l02553"></a>02553 <span class="comment">   * of being granted.</span>
<a name="l02554"></a>02554 <span class="comment">   */</span>
<a name="l02555"></a>02555   *pstatus = <a class="code" href="state__lock_8c.html#a1b7532d0b0321fdd328c9057087b1cfb">do_lock_op</a>(pentry,
<a name="l02556"></a>02556                         pcontext,
<a name="l02557"></a>02557                         pexport,
<a name="l02558"></a>02558                         <a class="code" href="fsal__types_8h.html#a24ab7f0b4ff810eb60102d971de19b20a8f700b40f6f195020b62a7f289d771b9">FSAL_OP_UNLOCK</a>,
<a name="l02559"></a>02559                         powner,
<a name="l02560"></a>02560                         plock,
<a name="l02561"></a>02561                         <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,   <span class="comment">/* no conflict expected */</span>
<a name="l02562"></a>02562                         <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l02563"></a>02563                         <a class="code" href="HashTable_8c.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l02564"></a>02564 
<a name="l02565"></a>02565   <span class="keywordflow">if</span>(*pstatus != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l02566"></a>02566     <a class="code" href="log_8h.html#a3cf3c22fac6bb9871e25007551caeb13">LogMajor</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02567"></a>02567              <span class="stringliteral">&quot;Unable to unlock FSAL, error=%s&quot;</span>,
<a name="l02568"></a>02568              <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(*pstatus));
<a name="l02569"></a>02569 
<a name="l02570"></a>02570   <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02571"></a>02571                <span class="stringliteral">&quot;----------------------------------------------------------------------&quot;</span>);
<a name="l02572"></a>02572   <a class="code" href="sal__functions_8h.html#ad62a073d73c565a7d2bbc850bc16e617">LogLock</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <a class="code" href="log_8h.html#afc14b587b4225c84f4796397df9489e2a59e3d6a98085b3dc7f143072242d2485">NIV_FULL_DEBUG</a>,
<a name="l02573"></a>02573           <span class="stringliteral">&quot;Done&quot;</span>, pentry, pcontext, powner, plock);
<a name="l02574"></a>02574   <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02575"></a>02575                <span class="stringliteral">&quot;----------------------------------------------------------------------&quot;</span>);
<a name="l02576"></a>02576 
<a name="l02577"></a>02577   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>) &amp;&amp;
<a name="l02578"></a>02578      <a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a0a066e3c604933ce4e6ceb2b81e9f46d">COMPONENT_MEMLEAKS</a>) &amp;&amp;
<a name="l02579"></a>02579      plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> == 0 &amp;&amp; plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a> == 0)
<a name="l02580"></a>02580     empty = LogList(<span class="stringliteral">&quot;Lock List&quot;</span>, pentry, &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list);
<a name="l02581"></a>02581 
<a name="l02582"></a>02582 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l02583"></a>02583 <span class="preprocessor"></span>  grant_blocked_locks(pentry, pcontext);
<a name="l02584"></a>02584 <span class="preprocessor">#endif</span>
<a name="l02585"></a>02585 <span class="preprocessor"></span>
<a name="l02586"></a>02586   pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02587"></a>02587 
<a name="l02588"></a>02588   <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02589"></a>02589 
<a name="l02590"></a>02590   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>) &amp;&amp;
<a name="l02591"></a>02591      <a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a0a066e3c604933ce4e6ceb2b81e9f46d">COMPONENT_MEMLEAKS</a>) &amp;&amp;
<a name="l02592"></a>02592      plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a> == 0 &amp;&amp; plock-&gt;<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a> == 0 &amp;&amp;
<a name="l02593"></a>02593      empty)
<a name="l02594"></a>02594     <a class="code" href="sal__functions_8h.html#a570a90379b6fa100ba1c7b7955182c29">dump_all_locks</a>(<span class="stringliteral">&quot;All locks (after unlock)&quot;</span>);
<a name="l02595"></a>02595 
<a name="l02596"></a>02596   <span class="keywordflow">return</span> *pstatus;
<a name="l02597"></a>02597 }
<a name="l02598"></a>02598 
<a name="l02599"></a>02599 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l02600"></a>02600 <span class="preprocessor"></span>
<a name="l02606"></a>02606 <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> state_cancel(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l02607"></a>02607                             <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l02608"></a>02608                             <a class="code" href="structexportlist____.html">exportlist_t</a>         * pexport,
<a name="l02609"></a>02609                             <a class="code" href="structstate__owner__t.html">state_owner_t</a>        * powner,
<a name="l02610"></a>02610                             <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * plock,
<a name="l02611"></a>02611                             <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>       * pstatus)
<a name="l02612"></a>02612 {
<a name="l02613"></a>02613   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a>    * glist;
<a name="l02614"></a>02614   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>   * found_entry;
<a name="l02615"></a>02615   <a class="code" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2">cache_inode_status_t</a>   cache_status;
<a name="l02616"></a>02616 
<a name="l02617"></a>02617   <span class="keywordflow">if</span>(pentry-&gt;<a class="code" href="structcache__entry__t.html#afa60c075430da0dbe9d5f4160f336294">type</a> != <a class="code" href="cache__inode_8h.html#a2aee8d2ff73574138b75922c7652162fa00512007115c06f83e278302d7c70590">REGULAR_FILE</a>)
<a name="l02618"></a>02618     {
<a name="l02619"></a>02619       <a class="code" href="sal__functions_8h.html#ad62a073d73c565a7d2bbc850bc16e617">LogLock</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <a class="code" href="log_8h.html#afc14b587b4225c84f4796397df9489e2aef0a258add3e3716c5776b34656b18ed">NIV_DEBUG</a>,
<a name="l02620"></a>02620               <span class="stringliteral">&quot;Bad Cancel&quot;</span>,
<a name="l02621"></a>02621               pentry, pcontext, powner, plock);
<a name="l02622"></a>02622       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba20ad4ad7596b102c028c12cf9821b710">STATE_BAD_TYPE</a>;
<a name="l02623"></a>02623       <span class="keywordflow">return</span> *pstatus;
<a name="l02624"></a>02624     }
<a name="l02625"></a>02625 
<a name="l02626"></a>02626   *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba3b6bf6508f079878391d80df01d93a9c">STATE_NOT_FOUND</a>;
<a name="l02627"></a>02627 
<a name="l02628"></a>02628   cache_status = <a class="code" href="cache__inode__lru_8c.html#a96bb243e361cf38c5ae8ac4c50c108f1" title="Function to let the state layer pin an entry.">cache_inode_inc_pin_ref</a>(pentry);
<a name="l02629"></a>02629 
<a name="l02630"></a>02630   <span class="keywordflow">if</span>(cache_status != <a class="code" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2a3fdbbb2367268ae84ac11d7b189643d8">CACHE_INODE_SUCCESS</a>)
<a name="l02631"></a>02631     {
<a name="l02632"></a>02632       *pstatus = <a class="code" href="sal__functions_8h.html#a8edcc5485a600a2f7d798bcdd33fdb09">cache_inode_status_to_state_status</a>(cache_status);
<a name="l02633"></a>02633       <a class="code" href="log_8h.html#aa7aee8ec65b5baafb430f8d2a7588d53">LogDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02634"></a>02634                <span class="stringliteral">&quot;Could not pin file&quot;</span>);
<a name="l02635"></a>02635       <span class="keywordflow">return</span> *pstatus;
<a name="l02636"></a>02636     }
<a name="l02637"></a>02637 
<a name="l02638"></a>02638   pthread_rwlock_wrlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02639"></a>02639 
<a name="l02640"></a>02640   <span class="comment">/* If lock list is empty, there really isn&#39;t any work for us to do. */</span>
<a name="l02641"></a>02641   <span class="keywordflow">if</span>(glist_empty(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list))
<a name="l02642"></a>02642     {
<a name="l02643"></a>02643       pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02644"></a>02644 
<a name="l02645"></a>02645       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02646"></a>02646       <a class="code" href="log_8h.html#aa7aee8ec65b5baafb430f8d2a7588d53">LogDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02647"></a>02647                <span class="stringliteral">&quot;Cancel success on file with no locks&quot;</span>);
<a name="l02648"></a>02648 
<a name="l02649"></a>02649       *pstatus = <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>;
<a name="l02650"></a>02650       <span class="keywordflow">return</span> *pstatus;
<a name="l02651"></a>02651     }
<a name="l02652"></a>02652 
<a name="l02653"></a>02653   <a class="code" href="nlm__list_8h.html#a39dd5015f511354bf29ba3cec9a3987b">glist_for_each</a>(glist, &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list)
<a name="l02654"></a>02654     {
<a name="l02655"></a>02655       found_entry = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_list);
<a name="l02656"></a>02656 
<a name="l02657"></a>02657       <span class="keywordflow">if</span>(<a class="code" href="sal__functions_8h.html#aafafe1a716e741dd5d3a2b3f579ddb94">different_owners</a>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>, powner))
<a name="l02658"></a>02658         <span class="keywordflow">continue</span>;
<a name="l02659"></a>02659 
<a name="l02660"></a>02660       <span class="comment">/* Can not cancel a lock once it is granted */</span>
<a name="l02661"></a>02661       <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a5df239de0c9c451a9be1020599048cc0">sle_blocked</a> == <a class="code" href="sal__data_8h.html#ac22c66114edbbb9326f72176a8e60c8facf0a49c1e4b5d2ab379c0b9c61df625d">STATE_NON_BLOCKING</a>)
<a name="l02662"></a>02662         <span class="keywordflow">continue</span>;
<a name="l02663"></a>02663 
<a name="l02664"></a>02664       <span class="keywordflow">if</span>(different_lock(&amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>, plock))
<a name="l02665"></a>02665         <span class="keywordflow">continue</span>;
<a name="l02666"></a>02666 
<a name="l02667"></a>02667       <span class="comment">/* Cancel the blocked lock */</span>
<a name="l02668"></a>02668       *pstatus = cancel_blocked_lock(pentry, pcontext, found_entry);
<a name="l02669"></a>02669 
<a name="l02670"></a>02670       <span class="comment">/* Check to see if we can grant any blocked locks. */</span>
<a name="l02671"></a>02671       grant_blocked_locks(pentry, pcontext);
<a name="l02672"></a>02672 
<a name="l02673"></a>02673       <span class="keywordflow">break</span>;
<a name="l02674"></a>02674     }
<a name="l02675"></a>02675 
<a name="l02676"></a>02676   <span class="comment">/* If the lock list has become zero; decrement the pin ref count pt placed */</span>
<a name="l02677"></a>02677   <span class="keywordflow">if</span>(glist_empty(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list))
<a name="l02678"></a>02678       <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02679"></a>02679 
<a name="l02680"></a>02680   pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02681"></a>02681 
<a name="l02682"></a>02682   <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l02683"></a>02683 
<a name="l02684"></a>02684   <span class="keywordflow">return</span> *pstatus;
<a name="l02685"></a>02685 }
<a name="l02686"></a>02686 <span class="preprocessor">#endif</span>
<a name="l02687"></a>02687 <span class="preprocessor"></span>
<a name="l02688"></a>02688 <span class="preprocessor">#ifdef _USE_NLM</span>
<a name="l02689"></a>02689 <span class="preprocessor"></span>
<a name="l02697"></a>02697 <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> state_nlm_notify(state_nsm_client_t   * pnsmclient,
<a name="l02698"></a>02698                                 <a class="code" href="structstate__t.html">state_t</a>              * pstate,
<a name="l02699"></a>02699                                 <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>       * pstatus)
<a name="l02700"></a>02700 {
<a name="l02701"></a>02701   <a class="code" href="structstate__owner__t.html">state_owner_t</a>      * powner;
<a name="l02702"></a>02702   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> * found_entry;
<a name="l02703"></a>02703   <a class="code" href="structexportlist____.html">exportlist_t</a>       * pexport;
<a name="l02704"></a>02704   <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    <a class="code" href="test__rw_8c.html#aa934ce3f0e2d2c60696f7010e2d0bf31">lock</a>;
<a name="l02705"></a>02705   <a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>      * pentry;
<a name="l02706"></a>02706   <span class="keywordtype">int</span>                  errcnt = 0;
<a name="l02707"></a>02707   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a>    newlocks;
<a name="l02708"></a>02708   <a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    <a class="code" href="nfs__file__content__flush__thread_8c.html#a60c0876d3df3d3a3aed3dab74d0f99c8">fsal_context</a>;
<a name="l02709"></a>02709   <a class="code" href="structfsal__status____.html">fsal_status_t</a>        fsal_status;
<a name="l02710"></a>02710   <a class="code" href="structstate__nlm__share__t.html">state_nlm_share_t</a>  * found_share;
<a name="l02711"></a>02711 
<a name="l02712"></a>02712   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>))
<a name="l02713"></a>02713     {
<a name="l02714"></a>02714       <span class="keywordtype">char</span> client[HASHTABLE_DISPLAY_STRLEN];
<a name="l02715"></a>02715 
<a name="l02716"></a>02716       <a class="code" href="nlm__owner_8c.html#a04cf214737fa55bb4da684d60ec65e08">display_nsm_client</a>(pnsmclient, client);
<a name="l02717"></a>02717 
<a name="l02718"></a>02718       <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02719"></a>02719                    <span class="stringliteral">&quot;state_nlm_notify for %s&quot;</span>, client);
<a name="l02720"></a>02720     }
<a name="l02721"></a>02721 
<a name="l02722"></a>02722   init_glist(&amp;newlocks);
<a name="l02723"></a>02723 
<a name="l02724"></a>02724   <span class="comment">/* First remove byte range locks.</span>
<a name="l02725"></a>02725 <span class="comment">   * Only accept so many errors before giving up.</span>
<a name="l02726"></a>02726 <span class="comment">   */</span>
<a name="l02727"></a>02727   <span class="keywordflow">while</span>(errcnt &lt; <a class="code" href="state__lock_8c.html#a28a5cdc8c44e19322b948741e0344107">STATE_ERR_MAX</a>)
<a name="l02728"></a>02728     {
<a name="l02729"></a>02729       <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(pnsmclient-&gt;ssc_mutex);
<a name="l02730"></a>02730 
<a name="l02731"></a>02731       <span class="comment">/* We just need to find any file this client has locks on.</span>
<a name="l02732"></a>02732 <span class="comment">       * We pick the first lock the client holds, and use it&#39;s file.</span>
<a name="l02733"></a>02733 <span class="comment">       */</span>
<a name="l02734"></a>02734       found_entry = <a class="code" href="nlm__list_8h.html#a8485362f3c7549aa03d4b417003ffed3">glist_first_entry</a>(&amp;pnsmclient-&gt;ssc_lock_list,
<a name="l02735"></a>02735                                       <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>,
<a name="l02736"></a>02736                                       sle_client_locks);
<a name="l02737"></a>02737 
<a name="l02738"></a>02738       <span class="comment">/* If we don&#39;t find any entries, then we are done. */</span>
<a name="l02739"></a>02739       <span class="keywordflow">if</span>(found_entry == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l02740"></a>02740         {
<a name="l02741"></a>02741           <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(pnsmclient-&gt;ssc_mutex);
<a name="l02742"></a>02742           <span class="keywordflow">break</span>;
<a name="l02743"></a>02743         }
<a name="l02744"></a>02744 
<a name="l02745"></a>02745       <span class="comment">/* Get a reference so the lock entry will still be valid when we release the ssc_mutex */</span>
<a name="l02746"></a>02746       <a class="code" href="state__lock_8c.html#a0385907ca0d4bed7af36c0feb8c52c33">lock_entry_inc_ref</a>(found_entry);
<a name="l02747"></a>02747 
<a name="l02748"></a>02748       <span class="comment">/* Remove from the client lock list */</span>
<a name="l02749"></a>02749       glist_del(&amp;found_entry-&gt;sle_client_locks);
<a name="l02750"></a>02750 
<a name="l02751"></a>02751       <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abb0ab635935d64b79bb2a6d3ee328731">sle_state</a> == pstate)
<a name="l02752"></a>02752         {
<a name="l02753"></a>02753           <span class="comment">/* This is a new lock acquired since the client rebooted, retain it. */</span>
<a name="l02754"></a>02754           LogEntry(<span class="stringliteral">&quot;Don&#39;t release new lock&quot;</span>, found_entry);
<a name="l02755"></a>02755           glist_add_tail(&amp;newlocks, &amp;found_entry-&gt;sle_client_locks);
<a name="l02756"></a>02756           <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(pnsmclient-&gt;ssc_mutex);
<a name="l02757"></a>02757           <span class="keywordflow">continue</span>;
<a name="l02758"></a>02758         }
<a name="l02759"></a>02759 
<a name="l02760"></a>02760       LogEntry(<span class="stringliteral">&quot;Release client locks based on&quot;</span>, found_entry);
<a name="l02761"></a>02761 
<a name="l02762"></a>02762       <span class="comment">/* Move this entry to the end of the list (this will help if errors occur) */</span>
<a name="l02763"></a>02763       glist_add_tail(&amp;pnsmclient-&gt;ssc_lock_list, &amp;found_entry-&gt;sle_client_locks);
<a name="l02764"></a>02764 
<a name="l02765"></a>02765       <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(pnsmclient-&gt;ssc_mutex);
<a name="l02766"></a>02766 
<a name="l02767"></a>02767       <span class="comment">/* Extract the cache inode entry from the lock entry and release the lock entry */</span>
<a name="l02768"></a>02768       pentry  = found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#aab01a34cef6e6bbeea32a83e906b7f32">sle_pentry</a>;
<a name="l02769"></a>02769       powner  = found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a>;
<a name="l02770"></a>02770       pexport = found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>;
<a name="l02771"></a>02771 
<a name="l02772"></a>02772       pthread_rwlock_wrlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02773"></a>02773 
<a name="l02774"></a>02774       <a class="code" href="state__lock_8c.html#aafed8460a8729acbd1e617f95606550e">lock_entry_dec_ref</a>(found_entry);
<a name="l02775"></a>02775 
<a name="l02776"></a>02776       pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02777"></a>02777 
<a name="l02778"></a>02778       <span class="comment">/* Make lock that covers the whole file - type doesn&#39;t matter for unlock */</span>
<a name="l02779"></a>02779       lock.<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a>   = <a class="code" href="fsal__types_8h.html#aab76e308a0e07a7fcb4f4182ca3c098caa8633965558922590799e083782fb423">FSAL_LOCK_R</a>;
<a name="l02780"></a>02780       lock.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>  = 0;
<a name="l02781"></a>02781       lock.<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a> = 0;
<a name="l02782"></a>02782 
<a name="l02783"></a>02783       <span class="comment">/* construct the fsal context based on the export and root credential */</span>
<a name="l02784"></a>02784       fsal_status = <a class="code" href="fsal__glue_8c.html#ac9d7f36333e895d045a6e484589fda10">FSAL_GetClientContext</a>(&amp;fsal_context,
<a name="l02785"></a>02785                                           &amp;pexport-&gt;<a class="code" href="structexportlist____.html#abbe82cf495253f375cd7f4bf47406aca">FS_export_context</a>,
<a name="l02786"></a>02786                                           0,
<a name="l02787"></a>02787                                           0,
<a name="l02788"></a>02788                                           <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l02789"></a>02789                                           0);
<a name="l02790"></a>02790       <span class="keywordflow">if</span>(<a class="code" href="fsal_8h.html#a7c2a97ec2fa552dea8e497c7dd8a2b86">FSAL_IS_ERROR</a>(fsal_status))
<a name="l02791"></a>02791         {
<a name="l02792"></a>02792           <span class="comment">/* log error here , and continue? */</span>
<a name="l02793"></a>02793           <a class="code" href="log_8h.html#aa7aee8ec65b5baafb430f8d2a7588d53">LogDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02794"></a>02794                    <span class="stringliteral">&quot;FSAL_GetClientConext failed&quot;</span>);
<a name="l02795"></a>02795           <span class="keywordflow">continue</span>;
<a name="l02796"></a>02796         }
<a name="l02797"></a>02797 
<a name="l02798"></a>02798       <span class="comment">/* Make sure we hold an lru ref to the cache inode while calling unlock */</span>
<a name="l02799"></a>02799       <span class="keywordflow">if</span>(<a class="code" href="cache__inode__lru_8c.html#a2c29ae784216cbb96ec55c6460f44bbb" title="Get a reference.">cache_inode_lru_ref</a>(pentry, 0) != <a class="code" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2a3fdbbb2367268ae84ac11d7b189643d8">CACHE_INODE_SUCCESS</a>)
<a name="l02800"></a>02800         <a class="code" href="test__findlog_8c.html#adfd9432c5478fa14c7d678edb301feed">LogCrit</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02801"></a>02801                 <span class="stringliteral">&quot;Ugliness - cache_inode_lru_ref has returned non-success&quot;</span>);
<a name="l02802"></a>02802 
<a name="l02803"></a>02803       <span class="comment">/* Remove all locks held by this NLM Client on the file */</span>
<a name="l02804"></a>02804       <span class="keywordflow">if</span>(<a class="code" href="sal__functions_8h.html#a4d80449370d509288b5e94bca7944324">state_unlock</a>(pentry,
<a name="l02805"></a>02805                       &amp;fsal_context,
<a name="l02806"></a>02806                       pexport,
<a name="l02807"></a>02807                       powner,
<a name="l02808"></a>02808                       pstate,
<a name="l02809"></a>02809                       &amp;lock,
<a name="l02810"></a>02810                       pstatus) != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l02811"></a>02811         {
<a name="l02812"></a>02812           <span class="comment">/* Increment the error count and try the next lock, with any luck</span>
<a name="l02813"></a>02813 <span class="comment">           * the memory pressure which is causing the problem will resolve itself.</span>
<a name="l02814"></a>02814 <span class="comment">           */</span>
<a name="l02815"></a>02815           <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02816"></a>02816                        <span class="stringliteral">&quot;state_unlock returned %s&quot;</span>,
<a name="l02817"></a>02817                        <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(*pstatus));
<a name="l02818"></a>02818           errcnt++;
<a name="l02819"></a>02819         }
<a name="l02820"></a>02820 
<a name="l02821"></a>02821       <span class="comment">/* Release the lru ref to the cache inode we held while calling unlock */</span>
<a name="l02822"></a>02822       <a class="code" href="cache__inode__lru_8c.html#a84096eac6e9589aed54c83040a4b0b2a" title="Relinquish a reference.">cache_inode_lru_unref</a>(pentry, 0);
<a name="l02823"></a>02823     }
<a name="l02824"></a>02824 
<a name="l02825"></a>02825   <span class="comment">/* Now remove NLM_SHARE reservations.</span>
<a name="l02826"></a>02826 <span class="comment">   * Only accept so many errors before giving up.</span>
<a name="l02827"></a>02827 <span class="comment">   */</span>
<a name="l02828"></a>02828   <span class="keywordflow">while</span>(errcnt &lt; <a class="code" href="state__lock_8c.html#a28a5cdc8c44e19322b948741e0344107">STATE_ERR_MAX</a>)
<a name="l02829"></a>02829     {
<a name="l02830"></a>02830       <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(pnsmclient-&gt;ssc_mutex);
<a name="l02831"></a>02831 
<a name="l02832"></a>02832       <span class="comment">/* We just need to find any file this client has locks on.</span>
<a name="l02833"></a>02833 <span class="comment">       * We pick the first lock the client holds, and use it&#39;s file.</span>
<a name="l02834"></a>02834 <span class="comment">       */</span>
<a name="l02835"></a>02835       found_share = <a class="code" href="nlm__list_8h.html#a8485362f3c7549aa03d4b417003ffed3">glist_first_entry</a>(&amp;pnsmclient-&gt;ssc_share_list,
<a name="l02836"></a>02836                                       <a class="code" href="structstate__nlm__share__t.html">state_nlm_share_t</a>,
<a name="l02837"></a>02837                                       sns_share_per_client);
<a name="l02838"></a>02838 
<a name="l02839"></a>02839       <span class="comment">/* If we don&#39;t find any entries, then we are done. */</span>
<a name="l02840"></a>02840       <span class="keywordflow">if</span>(found_share == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)
<a name="l02841"></a>02841         {
<a name="l02842"></a>02842           <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(pnsmclient-&gt;ssc_mutex);
<a name="l02843"></a>02843           <span class="keywordflow">break</span>;
<a name="l02844"></a>02844         }
<a name="l02845"></a>02845 
<a name="l02846"></a>02846       <span class="comment">/* Extract the cache inode entry from the share */</span>
<a name="l02847"></a>02847       pentry  = found_share-&gt;<a class="code" href="structstate__nlm__share__t.html#a772fc274c1fe678ce9d2243b56f6f9eb">sns_pentry</a>;
<a name="l02848"></a>02848       powner  = found_share-&gt;<a class="code" href="structstate__nlm__share__t.html#ab49e6bdc8c276498b85b965013ff4544">sns_powner</a>;
<a name="l02849"></a>02849       pexport = found_share-&gt;<a class="code" href="structstate__nlm__share__t.html#ae2d33a09583019c4a0d1b5edf12ccddf">sns_pexport</a>;
<a name="l02850"></a>02850 
<a name="l02851"></a>02851       <span class="comment">/* get a reference to the owner */</span>
<a name="l02853"></a>02853 <span class="preprocessor">#ifdef FSF</span>
<a name="l02854"></a>02854 <span class="preprocessor"></span>      <a class="code" href="sal__functions_8h.html#a0f5e8266f6e939de262ee6677326057f">inc_state_owner_ref_locked</a>(powner);
<a name="l02855"></a>02855 <span class="preprocessor">#endif</span>
<a name="l02856"></a>02856 <span class="preprocessor"></span>
<a name="l02857"></a>02857       <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(pnsmclient-&gt;ssc_mutex);
<a name="l02858"></a>02858 
<a name="l02859"></a>02859       <span class="comment">/* construct the fsal context based on the export and root credential */</span>
<a name="l02860"></a>02860       fsal_status = <a class="code" href="fsal__glue_8c.html#ac9d7f36333e895d045a6e484589fda10">FSAL_GetClientContext</a>(&amp;fsal_context,
<a name="l02861"></a>02861                                           &amp;pexport-&gt;<a class="code" href="structexportlist____.html#abbe82cf495253f375cd7f4bf47406aca">FS_export_context</a>,
<a name="l02862"></a>02862                                           0,
<a name="l02863"></a>02863                                           0,
<a name="l02864"></a>02864                                           <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,
<a name="l02865"></a>02865                                           0);
<a name="l02866"></a>02866       <span class="keywordflow">if</span>(<a class="code" href="fsal_8h.html#a7c2a97ec2fa552dea8e497c7dd8a2b86">FSAL_IS_ERROR</a>(fsal_status))
<a name="l02867"></a>02867         {
<a name="l02868"></a>02868 <span class="preprocessor">#ifdef FSF</span>
<a name="l02869"></a>02869 <span class="preprocessor"></span>          <a class="code" href="sal__functions_8h.html#a92d4e966d9abde529120aab99f932fda">dec_state_owner_ref_locked</a>(powner);
<a name="l02870"></a>02870 <span class="preprocessor">#endif</span>
<a name="l02871"></a>02871 <span class="preprocessor"></span>
<a name="l02872"></a>02872           <span class="comment">/* log error here , and continue? */</span>
<a name="l02873"></a>02873           <a class="code" href="log_8h.html#aa7aee8ec65b5baafb430f8d2a7588d53">LogDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02874"></a>02874                    <span class="stringliteral">&quot;FSAL_GetClientConext failed&quot;</span>);
<a name="l02875"></a>02875           <span class="keywordflow">continue</span>;
<a name="l02876"></a>02876         }
<a name="l02877"></a>02877 
<a name="l02878"></a>02878       <span class="comment">/* Remove all shares held by this NSM Client and Owner on the file */</span>
<a name="l02879"></a>02879       <span class="keywordflow">if</span>(<a class="code" href="sal__functions_8h.html#a1cd1f25e3ec7945797d7dec4d8511b8e">state_nlm_unshare</a>(pentry,
<a name="l02880"></a>02880                            &amp;fsal_context,
<a name="l02881"></a>02881                            <a class="code" href="sal__functions_8h.html#a8b00aa79fa478e758e007ae881208e7f">OPEN4_SHARE_ACCESS_NONE</a>,
<a name="l02882"></a>02882                            <a class="code" href="nfsv40_8h.html#a36aab841b71c1078f9d2d4e0009f9535">OPEN4_SHARE_DENY_NONE</a>,
<a name="l02883"></a>02883                            powner,
<a name="l02884"></a>02884                            pstatus) != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l02885"></a>02885         {
<a name="l02886"></a>02886           <span class="comment">/* Increment the error count and try the next share, with any luck</span>
<a name="l02887"></a>02887 <span class="comment">           * the memory pressure which is causing the problem will resolve itself.</span>
<a name="l02888"></a>02888 <span class="comment">           */</span>
<a name="l02889"></a>02889           <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02890"></a>02890                        <span class="stringliteral">&quot;state_nlm_unshare returned %s&quot;</span>,
<a name="l02891"></a>02891                        <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(*pstatus));
<a name="l02892"></a>02892           errcnt++;
<a name="l02893"></a>02893         }
<a name="l02894"></a>02894 
<a name="l02895"></a>02895 <span class="preprocessor">#ifdef FSF</span>
<a name="l02896"></a>02896 <span class="preprocessor"></span>      <a class="code" href="sal__functions_8h.html#a92d4e966d9abde529120aab99f932fda">dec_state_owner_ref_locked</a>(powner);
<a name="l02897"></a>02897 <span class="preprocessor">#endif</span>
<a name="l02898"></a>02898 <span class="preprocessor"></span>    }
<a name="l02899"></a>02899 
<a name="l02900"></a>02900   <span class="comment">/* Put locks from current client incarnation onto end of list */</span>
<a name="l02901"></a>02901   <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(pnsmclient-&gt;ssc_mutex);
<a name="l02902"></a>02902   glist_add_list_tail(&amp;pnsmclient-&gt;ssc_lock_list, &amp;newlocks);
<a name="l02903"></a>02903   <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(pnsmclient-&gt;ssc_mutex);
<a name="l02904"></a>02904   <a class="code" href="log_8h.html#a8ca2131f27bca0bd0e870c3c2da64cb1">LogFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <span class="stringliteral">&quot;DONE&quot;</span>);
<a name="l02905"></a>02905 
<a name="l02906"></a>02906   <span class="keywordflow">return</span> *pstatus;
<a name="l02907"></a>02907 }
<a name="l02908"></a>02908 <span class="preprocessor">#endif</span>
<a name="l02909"></a>02909 <span class="preprocessor"></span>
<a name="l02915"></a><a class="code" href="state__lock_8c.html#a5484f89afb2bb808af8fd85d44f64bf6">02915</a> <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a> <a class="code" href="sal__functions_8h.html#a5484f89afb2bb808af8fd85d44f64bf6">state_owner_unlock_all</a>(<a class="code" href="structfsal__op__context____.html">fsal_op_context_t</a>    * pcontext,
<a name="l02916"></a>02916                                       <a class="code" href="structstate__owner__t.html">state_owner_t</a>        * powner,
<a name="l02917"></a>02917                                       <a class="code" href="structstate__t.html">state_t</a>              * pstate,
<a name="l02918"></a>02918                                       <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5b">state_status_t</a>       * pstatus)
<a name="l02919"></a>02919 {
<a name="l02920"></a>02920   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a> * found_entry;
<a name="l02921"></a>02921   <a class="code" href="structexportlist____.html">exportlist_t</a>       * pexport;
<a name="l02922"></a>02922   <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    <a class="code" href="test__rw_8c.html#aa934ce3f0e2d2c60696f7010e2d0bf31">lock</a>;
<a name="l02923"></a>02923   <a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>      * pentry;
<a name="l02924"></a>02924   <span class="keywordtype">int</span>                  errcnt = 0;
<a name="l02925"></a>02925 
<a name="l02926"></a>02926   <span class="comment">/* Only accept so many errors before giving up. */</span>
<a name="l02927"></a>02927   <span class="keywordflow">while</span>(errcnt &lt; <a class="code" href="state__lock_8c.html#a28a5cdc8c44e19322b948741e0344107">STATE_ERR_MAX</a>)
<a name="l02928"></a>02928     {
<a name="l02929"></a>02929       <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(powner-&gt;<a class="code" href="structstate__owner__t.html#a48a1d1f3663a55fa4ee7180dfcc02238">so_mutex</a>);
<a name="l02930"></a>02930 
<a name="l02931"></a>02931       <span class="comment">/* We just need to find any file this owner has locks on.</span>
<a name="l02932"></a>02932 <span class="comment">       * We pick the first lock the owner holds, and use it&#39;s file.</span>
<a name="l02933"></a>02933 <span class="comment">       */</span>
<a name="l02934"></a>02934       found_entry = <a class="code" href="nlm__list_8h.html#a8485362f3c7549aa03d4b417003ffed3">glist_first_entry</a>(&amp;powner-&gt;<a class="code" href="structstate__owner__t.html#a769981c093a67e98f4b8aa95bdd122ed">so_lock_list</a>, <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>, sle_owner_locks);
<a name="l02935"></a>02935 
<a name="l02936"></a>02936       <span class="comment">/* If we don&#39;t find any entries, then we are done. */</span>
<a name="l02937"></a>02937       <span class="keywordflow">if</span>((found_entry == <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) || (found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#abb0ab635935d64b79bb2a6d3ee328731">sle_state</a> != pstate))
<a name="l02938"></a>02938       {
<a name="l02939"></a>02939         <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(powner-&gt;<a class="code" href="structstate__owner__t.html#a48a1d1f3663a55fa4ee7180dfcc02238">so_mutex</a>);
<a name="l02940"></a>02940         <span class="keywordflow">break</span>;
<a name="l02941"></a>02941       }
<a name="l02942"></a>02942 
<a name="l02943"></a>02943       <a class="code" href="state__lock_8c.html#a0385907ca0d4bed7af36c0feb8c52c33">lock_entry_inc_ref</a>(found_entry);
<a name="l02944"></a>02944 
<a name="l02945"></a>02945       <span class="comment">/* Move this entry to the end of the list (this will help if errors occur) */</span>
<a name="l02946"></a>02946       glist_del(&amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a387fd4963b7fa3864806f627ea602f47">sle_owner_locks</a>);
<a name="l02947"></a>02947       glist_add_tail(&amp;powner-&gt;<a class="code" href="structstate__owner__t.html#a769981c093a67e98f4b8aa95bdd122ed">so_lock_list</a>, &amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a387fd4963b7fa3864806f627ea602f47">sle_owner_locks</a>);
<a name="l02948"></a>02948 
<a name="l02949"></a>02949       <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(powner-&gt;<a class="code" href="structstate__owner__t.html#a48a1d1f3663a55fa4ee7180dfcc02238">so_mutex</a>);
<a name="l02950"></a>02950 
<a name="l02951"></a>02951       <span class="comment">/* Extract the cache inode entry from the lock entry and release the lock entry */</span>
<a name="l02952"></a>02952       pentry  = found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#aab01a34cef6e6bbeea32a83e906b7f32">sle_pentry</a>;
<a name="l02953"></a>02953       pexport = found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a44b6028d001ee22498655302ad003ca1">sle_pexport</a>;
<a name="l02954"></a>02954 
<a name="l02955"></a>02955       pthread_rwlock_wrlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02956"></a>02956 
<a name="l02957"></a>02957       <a class="code" href="state__lock_8c.html#aafed8460a8729acbd1e617f95606550e">lock_entry_dec_ref</a>(found_entry);
<a name="l02958"></a>02958 
<a name="l02959"></a>02959       pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l02960"></a>02960 
<a name="l02961"></a>02961       <span class="comment">/* Make lock that covers the whole file - type doesn&#39;t matter for unlock */</span>
<a name="l02962"></a>02962       lock.<a class="code" href="structfsal__lock__param__t.html#af92333e93eb13a24565eb97d40d4e79d">lock_type</a>   = <a class="code" href="fsal__types_8h.html#aab76e308a0e07a7fcb4f4182ca3c098caa8633965558922590799e083782fb423">FSAL_LOCK_R</a>;
<a name="l02963"></a>02963       lock.<a class="code" href="structfsal__lock__param__t.html#a170a307abeec4fbabbde67143abae136">lock_start</a>  = 0;
<a name="l02964"></a>02964       lock.<a class="code" href="structfsal__lock__param__t.html#a7d0118133370d4d72c5644389316792e">lock_length</a> = 0;
<a name="l02965"></a>02965 
<a name="l02966"></a>02966       <span class="comment">/* Make sure we hold an lru ref to the cache inode while calling unlock */</span>
<a name="l02967"></a>02967       <span class="keywordflow">if</span>(<a class="code" href="cache__inode__lru_8c.html#a2c29ae784216cbb96ec55c6460f44bbb" title="Get a reference.">cache_inode_lru_ref</a>(pentry, 0) != <a class="code" href="cache__inode_8h.html#aa6929668cedf7463f35a22998b8e08d2a3fdbbb2367268ae84ac11d7b189643d8">CACHE_INODE_SUCCESS</a>)
<a name="l02968"></a>02968         <a class="code" href="test__findlog_8c.html#adfd9432c5478fa14c7d678edb301feed">LogCrit</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02969"></a>02969                 <span class="stringliteral">&quot;Ugliness - cache_inode_lru_ref has returned non-success&quot;</span>);
<a name="l02970"></a>02970 
<a name="l02971"></a>02971       <span class="comment">/* Remove all locks held by this owner on the file */</span>
<a name="l02972"></a>02972       <span class="keywordflow">if</span>(<a class="code" href="sal__functions_8h.html#a4d80449370d509288b5e94bca7944324">state_unlock</a>(pentry,
<a name="l02973"></a>02973                       pcontext,
<a name="l02974"></a>02974                       pexport,
<a name="l02975"></a>02975                       powner,
<a name="l02976"></a>02976                       pstate,
<a name="l02977"></a>02977                       &amp;lock,
<a name="l02978"></a>02978                       pstatus) != <a class="code" href="sal__data_8h.html#abaefb535451d8c22b6d4074d63effd5ba95fdd6b02cbc698e4bd1a4eafe1661ff">STATE_SUCCESS</a>)
<a name="l02979"></a>02979         {
<a name="l02980"></a>02980           <span class="comment">/* Increment the error count and try the next lock, with any luck</span>
<a name="l02981"></a>02981 <span class="comment">           * the memory pressure which is causing the problem will resolve itself.</span>
<a name="l02982"></a>02982 <span class="comment">           */</span>
<a name="l02983"></a>02983           <a class="code" href="log_8h.html#aa7aee8ec65b5baafb430f8d2a7588d53">LogDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>,
<a name="l02984"></a>02984                <span class="stringliteral">&quot;state_unlock failed %s&quot;</span>,
<a name="l02985"></a>02985                <a class="code" href="sal__functions_8h.html#a5c251a49aca6c7d4fc07bcc9f925ec07">state_err_str</a>(*pstatus));
<a name="l02986"></a>02986           errcnt++;
<a name="l02987"></a>02987         }
<a name="l02988"></a>02988 
<a name="l02989"></a>02989       <span class="comment">/* Release the lru ref to the cache inode we held while calling unlock */</span>
<a name="l02990"></a>02990       <a class="code" href="cache__inode__lru_8c.html#a84096eac6e9589aed54c83040a4b0b2a" title="Relinquish a reference.">cache_inode_lru_unref</a>(pentry, 0);
<a name="l02991"></a>02991     }
<a name="l02992"></a>02992   <span class="keywordflow">return</span> *pstatus;
<a name="l02993"></a>02993 }
<a name="l02994"></a>02994 
<a name="l02995"></a>02995 <span class="preprocessor">#ifdef _USE_BLOCKING_LOCKS</span>
<a name="l02996"></a>02996 <span class="preprocessor"></span>
<a name="l02997"></a>02997 <span class="keywordtype">void</span> find_blocked_lock_upcall(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l02998"></a>02998                               <span class="keywordtype">void</span>                 * powner,
<a name="l02999"></a>02999                               <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * plock,
<a name="l03000"></a>03000                               state_grant_type_t     grant_type)
<a name="l03001"></a>03001 {
<a name="l03002"></a>03002   <a class="code" href="structstate__lock__entry__t.html">state_lock_entry_t</a>   * found_entry;
<a name="l03003"></a>03003   <span class="keyword">struct </span><a class="code" href="structglist__head.html">glist_head</a>    * glist;
<a name="l03004"></a>03004   <a class="code" href="sal__data_8h.html#a3035370b7b027cc7c897284b50c5fc12">state_block_data_t</a>   * pblock;
<a name="l03005"></a>03005 
<a name="l03006"></a>03006   <a class="code" href="common__utils_8h.html#a13190861330e48fe885da6b2671876a9">P</a>(blocked_locks_mutex);
<a name="l03007"></a>03007 
<a name="l03008"></a>03008   <a class="code" href="nlm__list_8h.html#a39dd5015f511354bf29ba3cec9a3987b">glist_for_each</a>(glist, &amp;state_blocked_locks)
<a name="l03009"></a>03009     {
<a name="l03010"></a>03010       pblock = <a class="code" href="nlm__list_8h.html#a784e8eeb1062636179222052812766a4">glist_entry</a>(glist, <a class="code" href="sal__data_8h.html#a3035370b7b027cc7c897284b50c5fc12">state_block_data_t</a>, sbd_list);
<a name="l03011"></a>03011 
<a name="l03012"></a>03012       found_entry = pblock-&gt;sbd_lock_entry;
<a name="l03013"></a>03013 
<a name="l03014"></a>03014       <span class="comment">/* Check if for same file */</span>
<a name="l03015"></a>03015       <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#aab01a34cef6e6bbeea32a83e906b7f32">sle_pentry</a> != pentry)
<a name="l03016"></a>03016         <span class="keywordflow">continue</span>;
<a name="l03017"></a>03017 
<a name="l03018"></a>03018       <span class="comment">/* Check if for same owner */</span>
<a name="l03019"></a>03019       <span class="keywordflow">if</span>(found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#adf890d0e8663092452500dd22eac76e3">sle_owner</a> != powner)
<a name="l03020"></a>03020         <span class="keywordflow">continue</span>;
<a name="l03021"></a>03021 
<a name="l03022"></a>03022       <span class="comment">/* Check if same lock */</span>
<a name="l03023"></a>03023       <span class="keywordflow">if</span>(different_lock(&amp;found_entry-&gt;<a class="code" href="structstate__lock__entry__t.html#a29f54c1985776b109a0d073e2c091273">sle_lock</a>, plock))
<a name="l03024"></a>03024         <span class="keywordflow">continue</span>;
<a name="l03025"></a>03025 
<a name="l03026"></a>03026       <span class="comment">/* Put lock on list of locks granted by FSAL */</span>
<a name="l03027"></a>03027       glist_del(&amp;pblock-&gt;sbd_list);
<a name="l03028"></a>03028       glist_add_tail(&amp;state_notified_locks, &amp;pblock-&gt;sbd_list);
<a name="l03029"></a>03029       pblock-&gt;sbd_grant_type = grant_type;
<a name="l03030"></a>03030 
<a name="l03031"></a>03031       LogEntry(<span class="stringliteral">&quot;Blocked Lock found&quot;</span>, found_entry);
<a name="l03032"></a>03032 
<a name="l03033"></a>03033       <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(blocked_locks_mutex);
<a name="l03034"></a>03034 
<a name="l03035"></a>03035       signal_async_work();
<a name="l03036"></a>03036 
<a name="l03037"></a>03037       <span class="keywordflow">return</span>;
<a name="l03038"></a>03038     } <span class="comment">/* glist_for_each_safe */</span>
<a name="l03039"></a>03039 
<a name="l03040"></a>03040   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>) &amp;&amp;
<a name="l03041"></a>03041      <a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a0a066e3c604933ce4e6ceb2b81e9f46d">COMPONENT_MEMLEAKS</a>))
<a name="l03042"></a>03042     LogBlockedList(<span class="stringliteral">&quot;Blocked Lock List&quot;</span>, <a class="code" href="Getopt_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, &amp;state_blocked_locks);
<a name="l03043"></a>03043 
<a name="l03044"></a>03044   <a class="code" href="common__utils_8h.html#a5a9b6f8030959507eee365b226d63b00">V</a>(blocked_locks_mutex);
<a name="l03045"></a>03045 
<a name="l03046"></a>03046   <span class="keywordflow">if</span>(<a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>) &amp;&amp;
<a name="l03047"></a>03047      <a class="code" href="log_8h.html#ad2b900e4d4ae3a366d0690930c8a68aa">isFullDebug</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a0a066e3c604933ce4e6ceb2b81e9f46d">COMPONENT_MEMLEAKS</a>))
<a name="l03048"></a>03048     {
<a name="l03049"></a>03049       pthread_rwlock_rdlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l03050"></a>03050 
<a name="l03051"></a>03051       LogList(<span class="stringliteral">&quot;File Lock List&quot;</span>, pentry, &amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list);
<a name="l03052"></a>03052 
<a name="l03053"></a>03053       pthread_rwlock_unlock(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a5c113e24a9432c130ce0530cf05b7c03">state_lock</a>);
<a name="l03054"></a>03054     }
<a name="l03055"></a>03055 
<a name="l03056"></a>03056   <span class="comment">/* We must be out of sync with FSAL, this is fatal */</span>
<a name="l03057"></a>03057   <a class="code" href="state__lock_8c.html#ab374e881221a11ba142358747dd37603">LogLockDesc</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <a class="code" href="log_8h.html#a443fddaae6c1e4b7af6dd75ad089c9bc">NIV_MAJOR</a>,
<a name="l03058"></a>03058               <span class="stringliteral">&quot;Blocked Lock Not Found for&quot;</span>, pentry, powner, plock);
<a name="l03059"></a>03059   <a class="code" href="log_8h.html#a4566d092fb3fb47391fec6b878e8aa7b">LogFatal</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <span class="stringliteral">&quot;Locks out of sync with FSAL&quot;</span>);
<a name="l03060"></a>03060 }
<a name="l03061"></a>03061 
<a name="l03067"></a>03067 <span class="keywordtype">void</span> grant_blocked_lock_upcall(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l03068"></a>03068                                <span class="keywordtype">void</span>                 * powner,
<a name="l03069"></a>03069                                <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * plock)
<a name="l03070"></a>03070 {
<a name="l03071"></a>03071   <a class="code" href="state__lock_8c.html#ab374e881221a11ba142358747dd37603">LogLockDesc</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <a class="code" href="log_8h.html#afc14b587b4225c84f4796397df9489e2aef0a258add3e3716c5776b34656b18ed">NIV_DEBUG</a>,
<a name="l03072"></a>03072               <span class="stringliteral">&quot;Grant Upcall for&quot;</span>, pentry, powner, plock);
<a name="l03073"></a>03073 
<a name="l03074"></a>03074   find_blocked_lock_upcall(pentry, powner, plock, STATE_GRANT_FSAL);
<a name="l03075"></a>03075 }
<a name="l03076"></a>03076 
<a name="l03082"></a>03082 <span class="keywordtype">void</span> available_blocked_lock_upcall(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry,
<a name="l03083"></a>03083                                    <span class="keywordtype">void</span>                 * powner,
<a name="l03084"></a>03084                                    <a class="code" href="structfsal__lock__param__t.html">fsal_lock_param_t</a>    * plock)
<a name="l03085"></a>03085 {
<a name="l03086"></a>03086   <a class="code" href="state__lock_8c.html#ab374e881221a11ba142358747dd37603">LogLockDesc</a>(<a class="code" href="log_8h.html#aef38a41286a6a40320bc7d64135b1556a10a2ef3a74e9065c1cfd6e7b61e247b9">COMPONENT_STATE</a>, <a class="code" href="log_8h.html#afc14b587b4225c84f4796397df9489e2aef0a258add3e3716c5776b34656b18ed">NIV_DEBUG</a>,
<a name="l03087"></a>03087               <span class="stringliteral">&quot;Available Upcall for&quot;</span>, pentry, powner, plock);
<a name="l03088"></a>03088 
<a name="l03089"></a>03089   find_blocked_lock_upcall(pentry, powner, plock, STATE_GRANT_FSAL_AVAILABLE);
<a name="l03090"></a>03090 }
<a name="l03091"></a>03091 
<a name="l03092"></a>03092 <span class="preprocessor">#endif</span>
<a name="l03093"></a>03093 <span class="preprocessor"></span>
<a name="l03094"></a><a class="code" href="state__lock_8c.html#a5718c6b430191794314c3c3410d214ca">03094</a> <span class="keywordtype">void</span> <a class="code" href="sal__functions_8h.html#a5718c6b430191794314c3c3410d214ca">state_lock_wipe</a>(<a class="code" href="structcache__entry__t.html" title="Represents a cached inode.">cache_entry_t</a>        * pentry)
<a name="l03095"></a>03095 {
<a name="l03096"></a>03096   <span class="keywordflow">if</span>(glist_empty(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list))
<a name="l03097"></a>03097     <span class="keywordflow">return</span>;
<a name="l03098"></a>03098 
<a name="l03099"></a>03099   free_list(&amp;pentry-&gt;<a class="code" href="structcache__entry__t.html#a0767b2a90515593d88a51fe20dbcc55e">object</a>.<a class="code" href="unioncache__entry__t_1_1cache__inode__fsobj____.html#a92f6a1482b689768ea47e2979629125a">file</a>.lock_list);
<a name="l03100"></a>03100 
<a name="l03101"></a>03101   <a class="code" href="cache__inode__lru_8c.html#a9b53565faa2bf3bb8a20467385b35e03" title="Function to let the state layer rlease a pin.">cache_inode_dec_pin_ref</a>(pentry);
<a name="l03102"></a>03102 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Nov 21 2012 for nfs-ganesha by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>

# Generated by rpcgen.py from rpc.x on Wed Aug 23 12:33:09 2006
import rpc_const as const
import rpc_type as types
import xdrlib
from xdrlib import Error as XDRError

class nullclass(object):
    pass

class RPCPacker(xdrlib.Packer):
    pack_hyper = xdrlib.Packer.pack_hyper
    pack_string = xdrlib.Packer.pack_string
    pack_opaque = xdrlib.Packer.pack_opaque
    pack_int = xdrlib.Packer.pack_int
    pack_double = xdrlib.Packer.pack_double
    pack_float = xdrlib.Packer.pack_float
    pack_unsigned = xdrlib.Packer.pack_uint
    pack_quadruple = xdrlib.Packer.pack_double
    pack_uhyper = xdrlib.Packer.pack_uhyper
    pack_uint = xdrlib.Packer.pack_uint
    pack_bool = xdrlib.Packer.pack_bool
    def pack_auth_flavor(self, data):
        if data not in [const.AUTH_NONE, const.AUTH_SYS, const.AUTH_SHORT, const.AUTH_DH, const.RPCSEC_GSS]:
            raise XDRError, 'value=%s not in enum auth_flavor' % data
        self.pack_int(data)

    def pack_opaque_auth(self, data):
        if data.flavor is None:
            raise TypeError, 'data.flavor == None'
        self.pack_auth_flavor(data.flavor)
        if data.body is None:
            raise TypeError, 'data.body == None'
        if len(data.body) > 400:
            raise XDRError, 'array length too long for data.body'
        self.pack_opaque(data.body)

    def pack_msg_type(self, data):
        if data not in [const.CALL, const.REPLY]:
            raise XDRError, 'value=%s not in enum msg_type' % data
        self.pack_int(data)

    def pack_reply_stat(self, data):
        if data not in [const.MSG_ACCEPTED, const.MSG_DENIED]:
            raise XDRError, 'value=%s not in enum reply_stat' % data
        self.pack_int(data)

    def pack_accept_stat(self, data):
        if data not in [const.SUCCESS, const.PROG_UNAVAIL, const.PROG_MISMATCH, const.PROC_UNAVAIL, const.GARBAGE_ARGS, const.SYSTEM_ERR]:
            raise XDRError, 'value=%s not in enum accept_stat' % data
        self.pack_int(data)

    def pack_reject_stat(self, data):
        if data not in [const.RPC_MISMATCH, const.AUTH_ERROR]:
            raise XDRError, 'value=%s not in enum reject_stat' % data
        self.pack_int(data)

    def pack_auth_stat(self, data):
        if data not in [const.AUTH_OK, const.AUTH_BADCRED, const.AUTH_REJECTEDCRED, const.AUTH_BADVERF, const.AUTH_REJECTEDVERF, const.AUTH_TOOWEAK, const.AUTH_INVALIDRESP, const.AUTH_FAILED, const.AUTH_KERB_GENERIC, const.AUTH_TIMEEXPIRE, const.AUTH_TKT_FILE, const.AUTH_DECODE, const.AUTH_NET_ADDR, const.RPCSEC_GSS_CREDPROBLEM, const.RPCSEC_GSS_CTXPROBLEM]:
            raise XDRError, 'value=%s not in enum auth_stat' % data
        self.pack_int(data)

    def pack_rpc_msg(self, data):
        if data.xid is None:
            raise TypeError, 'data.xid == None'
        self.pack_uint(data.xid)
        if data.body is None:
            raise TypeError, 'data.body == None'
        if data.body.mtype is None:
            raise TypeError, 'data.body.mtype == None'
        self.pack_msg_type(data.body.mtype)
        if data.body.mtype == const.CALL:
            if data.body.cbody is None:
                raise TypeError, 'data.body.cbody == None'
            self.pack_call_body(data.body.cbody)
        elif data.body.mtype == const.REPLY:
            if data.body.rbody is None:
                raise TypeError, 'data.body.rbody == None'
            self.pack_reply_body(data.body.rbody)
        else:
            raise XDRError, 'bad switch=%s' % data.body.mtype

    def pack_call_body(self, data):
        if data.rpcvers is None:
            raise TypeError, 'data.rpcvers == None'
        self.pack_uint(data.rpcvers)
        if data.prog is None:
            raise TypeError, 'data.prog == None'
        self.pack_uint(data.prog)
        if data.vers is None:
            raise TypeError, 'data.vers == None'
        self.pack_uint(data.vers)
        if data.proc is None:
            raise TypeError, 'data.proc == None'
        self.pack_uint(data.proc)
        if data.cred is None:
            raise TypeError, 'data.cred == None'
        self.pack_opaque_auth(data.cred)
        if data.verf is None:
            raise TypeError, 'data.verf == None'
        self.pack_opaque_auth(data.verf)

    def pack_reply_body(self, data):
        if data.stat is None:
            raise TypeError, 'data.stat == None'
        self.pack_reply_stat(data.stat)
        if data.stat == const.MSG_ACCEPTED:
            if data.areply is None:
                raise TypeError, 'data.areply == None'
            self.pack_accepted_reply(data.areply)
        elif data.stat == const.MSG_DENIED:
            if data.rreply is None:
                raise TypeError, 'data.rreply == None'
            self.pack_rejected_reply(data.rreply)
        else:
            raise XDRError, 'bad switch=%s' % data.stat

    def pack_accepted_reply(self, data):
        if data.verf is None:
            raise TypeError, 'data.verf == None'
        self.pack_opaque_auth(data.verf)
        if data.reply_data is None:
            raise TypeError, 'data.reply_data == None'
        if data.reply_data.stat is None:
            raise TypeError, 'data.reply_data.stat == None'
        self.pack_accept_stat(data.reply_data.stat)
        if data.reply_data.stat == const.SUCCESS:
            if data.reply_data.results is None:
                raise TypeError, 'data.reply_data.results == None'
            self.pack_fopaque(0, data.reply_data.results)
        elif data.reply_data.stat == const.PROG_MISMATCH:
            if data.reply_data.mismatch_info is None:
                raise TypeError, 'data.reply_data.mismatch_info == None'
            if data.reply_data.mismatch_info.low is None:
                raise TypeError, 'data.reply_data.mismatch_info.low == None'
            self.pack_uint(data.reply_data.mismatch_info.low)
            if data.reply_data.mismatch_info.high is None:
                raise TypeError, 'data.reply_data.mismatch_info.high == None'
            self.pack_uint(data.reply_data.mismatch_info.high)
        else:
            pass

    def pack_rejected_reply(self, data):
        if data.stat is None:
            raise TypeError, 'data.stat == None'
        self.pack_reject_stat(data.stat)
        if data.stat == const.RPC_MISMATCH:
            if data.mismatch_info is None:
                raise TypeError, 'data.mismatch_info == None'
            if data.mismatch_info.low is None:
                raise TypeError, 'data.mismatch_info.low == None'
            self.pack_uint(data.mismatch_info.low)
            if data.mismatch_info.high is None:
                raise TypeError, 'data.mismatch_info.high == None'
            self.pack_uint(data.mismatch_info.high)
        elif data.stat == const.AUTH_ERROR:
            if data.astat is None:
                raise TypeError, 'data.astat == None'
            self.pack_auth_stat(data.astat)
        else:
            raise XDRError, 'bad switch=%s' % data.stat

class RPCUnpacker(xdrlib.Unpacker):
    unpack_hyper = xdrlib.Unpacker.unpack_hyper
    unpack_string = xdrlib.Unpacker.unpack_string
    unpack_opaque = xdrlib.Unpacker.unpack_opaque
    unpack_int = xdrlib.Unpacker.unpack_int
    unpack_double = xdrlib.Unpacker.unpack_double
    unpack_float = xdrlib.Unpacker.unpack_float
    unpack_unsigned = xdrlib.Unpacker.unpack_uint
    unpack_quadruple = xdrlib.Unpacker.unpack_double
    unpack_uhyper = xdrlib.Unpacker.unpack_uhyper
    unpack_uint = xdrlib.Unpacker.unpack_uint
    unpack_bool = xdrlib.Unpacker.unpack_bool
    def unpack_auth_flavor(self):
        data = self.unpack_int()
        if data not in [const.AUTH_NONE, const.AUTH_SYS, const.AUTH_SHORT, const.AUTH_DH, const.RPCSEC_GSS]:
            raise XDRError, 'value=%s not in enum auth_flavor' % data
        return data

    def unpack_opaque_auth(self):
        data = types.opaque_auth()
        data.flavor = self.unpack_auth_flavor()
        data.body = self.unpack_opaque()
        if len(data.body) > 400:
            raise XDRError, 'array length too long for data.body'
        return data

    def unpack_msg_type(self):
        data = self.unpack_int()
        if data not in [const.CALL, const.REPLY]:
            raise XDRError, 'value=%s not in enum msg_type' % data
        return data

    def unpack_reply_stat(self):
        data = self.unpack_int()
        if data not in [const.MSG_ACCEPTED, const.MSG_DENIED]:
            raise XDRError, 'value=%s not in enum reply_stat' % data
        return data

    def unpack_accept_stat(self):
        data = self.unpack_int()
        if data not in [const.SUCCESS, const.PROG_UNAVAIL, const.PROG_MISMATCH, const.PROC_UNAVAIL, const.GARBAGE_ARGS, const.SYSTEM_ERR]:
            raise XDRError, 'value=%s not in enum accept_stat' % data
        return data

    def unpack_reject_stat(self):
        data = self.unpack_int()
        if data not in [const.RPC_MISMATCH, const.AUTH_ERROR]:
            raise XDRError, 'value=%s not in enum reject_stat' % data
        return data

    def unpack_auth_stat(self):
        data = self.unpack_int()
        if data not in [const.AUTH_OK, const.AUTH_BADCRED, const.AUTH_REJECTEDCRED, const.AUTH_BADVERF, const.AUTH_REJECTEDVERF, const.AUTH_TOOWEAK, const.AUTH_INVALIDRESP, const.AUTH_FAILED, const.AUTH_KERB_GENERIC, const.AUTH_TIMEEXPIRE, const.AUTH_TKT_FILE, const.AUTH_DECODE, const.AUTH_NET_ADDR, const.RPCSEC_GSS_CREDPROBLEM, const.RPCSEC_GSS_CTXPROBLEM]:
            raise XDRError, 'value=%s not in enum auth_stat' % data
        return data

    def unpack_rpc_msg(self):
        data = types.rpc_msg()
        data.xid = self.unpack_uint()
        data.body = nullclass()
        data.body.mtype = self.unpack_msg_type()
        if data.body.mtype == const.CALL:
            data.body.cbody = self.unpack_call_body()
            data.body.arm = data.body.cbody
        elif data.body.mtype == const.REPLY:
            data.body.rbody = self.unpack_reply_body()
            data.body.arm = data.body.rbody
        else:
            raise XDRError, 'bad switch=%s' % data.body.mtype
        return data

    def unpack_call_body(self):
        data = types.call_body()
        data.rpcvers = self.unpack_uint()
        data.prog = self.unpack_uint()
        data.vers = self.unpack_uint()
        data.proc = self.unpack_uint()
        data.cred = self.unpack_opaque_auth()
        data.verf = self.unpack_opaque_auth()
        return data

    def unpack_reply_body(self):
        data = types.reply_body()
        data.stat = self.unpack_reply_stat()
        if data.stat == const.MSG_ACCEPTED:
            data.areply = self.unpack_accepted_reply()
            data.arm = data.areply
        elif data.stat == const.MSG_DENIED:
            data.rreply = self.unpack_rejected_reply()
            data.arm = data.rreply
        else:
            raise XDRError, 'bad switch=%s' % data.stat
        return data

    def unpack_accepted_reply(self):
        data = types.accepted_reply()
        data.verf = self.unpack_opaque_auth()
        data.reply_data = nullclass()
        data.reply_data.stat = self.unpack_accept_stat()
        if data.reply_data.stat == const.SUCCESS:
            data.reply_data.results = self.unpack_fopaque(0)
            data.reply_data.arm = data.reply_data.results
        elif data.reply_data.stat == const.PROG_MISMATCH:
            data.reply_data.mismatch_info = nullclass()
            data.reply_data.mismatch_info.low = self.unpack_uint()
            data.reply_data.mismatch_info.high = self.unpack_uint()
            data.reply_data.arm = data.reply_data.mismatch_info
        else:
            pass
            data.reply_data.arm = None
        return data

    def unpack_rejected_reply(self):
        data = types.rejected_reply()
        data.stat = self.unpack_reject_stat()
        if data.stat == const.RPC_MISMATCH:
            data.mismatch_info = nullclass()
            data.mismatch_info.low = self.unpack_uint()
            data.mismatch_info.high = self.unpack_uint()
            data.arm = data.mismatch_info
        elif data.stat == const.AUTH_ERROR:
            data.astat = self.unpack_auth_stat()
            data.arm = data.astat
        else:
            raise XDRError, 'bad switch=%s' % data.stat
        return data

